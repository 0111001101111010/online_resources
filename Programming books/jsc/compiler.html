<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--Converted with jLaTeX2HTML 2002-2-1 (1.70) JA patch-1.4
patched version by:  Kenshi Muto, Debian Project.
LaTeX2HTML 2002-2-1 (1.70),
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>CSE 5317/4305: Design and Construction of Compilers</title>
<meta name="description" content="CSE 5317/4305: Design and Construction of Compilers">
<meta name="keywords" content="long">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">

<meta name="Generator" content="jLaTeX2HTML v2002-2-1 JA patch-1.4">
<meta http-equiv="Content-Style-Type" content="text/css">

<link rel="STYLESHEET" href="compiler_files/long.css">

</head>

<body>

<p>
</p><h1 align="CENTER">CSE 5317/4305: Design and Construction of Compilers</h1>
<div>

<p align="CENTER"><strong>Leonidas Fegaras</strong></p>
<p align="CENTER"><i>University of Texas at Arlington, CSE</i></p>
</div>

<p>
</p><div align="CENTER">
Copyright Â©1999-2005 by Leonidas Fegaras
<br>
email:    fegaras@cse.uta.edu
<br>
web:      http://lambda.uta.edu/

</div>

<p>
<br>

</p><h2><a name="SECTION00010000000000000000">
Contents</a>
</h2>
<!--Table of Contents-->

<ul>
<li><a name="tex2html67" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION00020000000000000000">1 Introduction</a>
<ul>
<li><a name="tex2html68" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION00021000000000000000">1.1 What is a Compiler?</a>
</li><li><a name="tex2html69" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION00022000000000000000">1.2 What is the Challenge?</a>
</li><li><a name="tex2html70" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION00023000000000000000">1.3 Compiler Architecture</a>
</li></ul>
<br>
</li><li><a name="tex2html71" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION00030000000000000000">2 Lexical Analysis</a>
<ul>
<li><a name="tex2html72" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION00031000000000000000">2.1 Regular Expressions (REs)</a>
</li><li><a name="tex2html73" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION00032000000000000000">2.2 Deterministic Finite Automata (DFAs)</a>
</li><li><a name="tex2html74" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION00033000000000000000">2.3 Converting a Regular Expression into a Deterministic Finite Automaton</a>
</li><li><a name="tex2html75" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION00034000000000000000">2.4 Case Study: The Calculator Scanner</a>
</li></ul>
<br>
</li><li><a name="tex2html76" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION00040000000000000000">3 Parsing</a>
<ul>
<li><a name="tex2html77" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION00041000000000000000">3.1 Context-free Grammars</a>
</li><li><a name="tex2html78" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION00042000000000000000">3.2 Predictive Parsing</a>
</li><li><a name="tex2html79" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION00043000000000000000">3.3 Bottom-up Parsing</a>
</li><li><a name="tex2html80" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION00044000000000000000">3.4 Case Study: The Calculator Parser</a>
</li></ul>
<br>
</li><li><a name="tex2html81" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION00050000000000000000">4 Abstract Syntax</a>
<ul>
<li><a name="tex2html82" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION00051000000000000000">4.1 Building Abstract Syntax Trees in Java</a>
</li><li><a name="tex2html83" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION00052000000000000000">4.2 Building Abstract Syntax Trees in C</a>
</li><li><a name="tex2html84" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION00053000000000000000">4.3 Gen: A Java Package for Constructing and Manipulating Abstract Syntax Trees</a>
</li></ul>
<br>
</li><li><a name="tex2html85" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION00060000000000000000">5 Semantic Actions</a>
</li><li><a name="tex2html86" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION00070000000000000000">6 Semantic Analysis</a>
<ul>
<li><a name="tex2html87" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION00071000000000000000">6.1 Symbol Tables</a>
</li><li><a name="tex2html88" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION00072000000000000000">6.2 Types and Type Checking</a>
</li><li><a name="tex2html89" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION00073000000000000000">6.3 Case Study: The Calculator Interpreter</a>
</li></ul>
<br>
</li><li><a name="tex2html90" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION00080000000000000000">7 Activation Records</a>
<ul>
<li><a name="tex2html91" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION00081000000000000000">7.1 Run-Time Storage Organization</a>
</li><li><a name="tex2html92" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION00082000000000000000">7.2 Case Study: Activation Records for the MIPS Architecture</a>
</li></ul>
<br>
</li><li><a name="tex2html93" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION00090000000000000000">8 Intermediate Code</a>
<ul>
<li><a name="tex2html94" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION00091000000000000000">8.1 Translating Variables, Records, Arrays, and Strings</a>
</li><li><a name="tex2html95" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION00092000000000000000">8.2 Control Statements</a>
</li></ul>
<br>
</li><li><a name="tex2html96" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION000100000000000000000">9 Basic Blocks and Traces</a>
</li><li><a name="tex2html97" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION000110000000000000000">10 Instruction Selection</a>
</li><li><a name="tex2html98" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION000120000000000000000">11 Liveness Analysis</a>
</li><li><a name="tex2html99" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION000130000000000000000">12 Register Allocation</a>
<ul>
<li><a name="tex2html100" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION000131000000000000000">12.1 Register Allocation Using the Interference Graph</a>
</li><li><a name="tex2html101" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION000132000000000000000">12.2 Code Generation for Trees</a>
</li></ul>
<br>
</li><li><a name="tex2html102" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION000140000000000000000">13 Garbage Collection</a>
<ul>
<li><a name="tex2html103" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION000141000000000000000">13.1 Storage Allocation</a>
</li><li><a name="tex2html104" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION000142000000000000000">13.2 Automatic Garbage Collection</a>
</li><li><a name="tex2html105" href="http://lambda.uta.edu/cse5317/long/long.html#SECTION000143000000000000000">13.3 Other Issues</a>
</li></ul></li></ul>
<!--End of Table of Contents-->
<p>

</p><p>

</p><h1><a name="SECTION00020000000000000000">
1 Introduction</a>
</h1>

<p>

</p><h2><a name="SECTION00021000000000000000">
1.1 What is a Compiler?</a>
</h2>

<p>
A <em>compiler</em> is a program that translates a source program written
in some high-level programming language (such as Java) into machine
code for some computer architecture (such as the Intel Pentium
architecture).  The generated machine code can be later executed many
times against different data each time.

</p><p>
An <em>interpreter</em> reads an executable source program written in a
high-level programming language as well as data for this program, and
it runs the program against the data to produce some results.  One
example is the Unix shell interpreter, which runs operating system
commands interactively.

</p><p>
Note that both interpreters and compilers (like any other program) are
written in some high-level programming language (which may be
different from the language they accept) and they are translated into
machine code. For a example, a Java interpreter can be completely
written in Pascal, or even Java. The interpreter source program is
machine independent since it does not generate machine code. (Note the
difference between <em>generate</em> and <em>translated into</em> machine
code.)  An interpreter is generally slower than a compiler because it
processes and interprets each statement in a program as many times as
the number of the evaluations of this statement.  For example, when a
for-loop is interpreted, the statements inside the for-loop body will
be analyzed and evaluated on every loop step.  Some languages, such as
Java and Lisp, come with both an interpreter and a compiler.  Java
source programs (Java classes with <code>.java</code> extension) are
translated by the <code>javac</code> compiler into byte-code files (with
<code>.class</code> extension). The Java interpreter, <code>java</code>, called
the Java Virtual Machine (JVM), may actually interpret byte codes
directly or may internally compile them to macine code and then
execute that code.

</p><p>
Compilers and interpreters are not the only examples of translators.
Here are few more:

</p><p>
<table border="1" cellpadding="3">
<tbody><tr><td align="LEFT"><b>Source Language</b></td>
<td align="LEFT"><b>Translator</b></td>
<td align="LEFT"><b>Target Language</b></td>
</tr>
<tr><td align="LEFT">LaTeX</td>
<td align="LEFT">Text Formater</td>
<td align="LEFT">PostScript</td>
</tr>
<tr><td align="LEFT">SQL</td>
<td align="LEFT">database query optimizer</td>
<td align="LEFT">Query Evaluation Plan</td>
</tr>
<tr><td align="LEFT">Java</td>
<td align="LEFT">javac compiler</td>
<td align="LEFT">Java byte code</td>
</tr>
<tr><td align="LEFT">Java</td>
<td align="LEFT">cross-compiler</td>
<td align="LEFT">C++ code</td>
</tr>
<tr><td align="LEFT">English text</td>
<td align="LEFT">Natural Language Understanding</td>
<td align="LEFT">semantics (meaning)</td>
</tr>
<tr><td align="LEFT">Regular Expressions</td>
<td align="LEFT">JLex scanner generator</td>
<td align="LEFT">a scanner in Java</td>
</tr>
<tr><td align="LEFT">BNF of a language</td>
<td align="LEFT">CUP parser generator</td>
<td align="LEFT">a parser in Java</td>
</tr>
</tbody></table>

</p><p>
This course deals mainly with compilers for high-level programming
languages, but the same techniques apply to interpreters or to any other
compilation scheme.

</p><p>

</p><h2><a name="SECTION00022000000000000000">
1.2 What is the Challenge?</a>
</h2>

<p>
Many variations:

</p><ul>
<li>many programming languages (eg, FORTRAN, C++, Java)
</li>
<li>many programming paradigms (eg, object-oriented, functional, logic)
</li>
<li>many computer architectures (eg, MIPS, SPARC, Intel, alpha)
</li>
<li>many operating systems (eg, Linux, Solaris, Windows)
</li>
</ul>
Qualities of a compiler (in order of importance):

<ol>
<li>the compiler itself must be bug-free
</li>
<li>it must generate correct machine code
</li>
<li>the generated machine code must run fast
</li>
<li>the compiler itself must run fast (compilation time must be proportional to program size)
</li>
<li>the compiler must be portable (ie, modular, supporting separate compilation)
</li>
<li>it must print good diagnostics and error messages
</li>
<li>the generated code must work well with existing debuggers
</li>
<li>must have consistent and predictable optimization.
</li>
</ol>
Building a compiler requires knowledge of

<ul>
<li>programming languages (parameter passing, variable scoping, memory allocation, etc)
</li>
<li>theory (automata, context-free languages, etc)
</li>
<li>algorithms and data structures (hash tables, graph algorithms, dynamic programming, etc)
</li>
<li>computer architecture (assembly programming)
</li>
<li>software engineering.
</li>
</ul>
The course project (building a non-trivial compiler for a Pascal-like
language) will give you a hands-on experience on system implementation
that combines all this knowledge.

<p>

</p><h2><a name="SECTION00023000000000000000">
1.3 Compiler Architecture</a>
</h2>

<p>
A compiler can be viewed as a program that accepts a source code (such
as a Java program) and generates machine code for some computer
architecture. Suppose that you want to build compilers for <i>n</i>
programming languages (eg, FORTRAN, C, C++, Java, BASIC, etc) and you
want these compilers to run on <i>m</i> different architectures (eg,
MIPS, SPARC, Intel, alpha, etc). If you do that naively, you need to
write <i>n</i>*<i>m</i> compilers, one for each language-architecture
combination.

</p><p>
The holly grail of portability in compilers is to do the same thing by
writing <i>n</i> + <i>m</i> programs only. How? You use a universal <em>Intermediate Representation</em> (<em>IR</em>) and you make the compiler a
two-phase compiler.  An IR is typically a tree-like data structure
that captures the basic features of most computer architectures.  One
example of an IR tree node is a representation of a 3-address
instruction, such as <!-- MATH
 $d\leftarrow s_1+s_2$
 -->
<i>d</i> <img src="compiler_files/img1.png" alt="$ \leftarrow$" align="BOTTOM" border="0" height="10" width="17"> <i>s</i><sub>1</sub> + <i>s</i><sub>2</sub>, that gets two source
addresses, <i>s</i><sub>1</sub> and <i>s</i><sub>2</sub>, (ie. two IR trees) and produces one
destination address, <i>d</i>.  The first phase of this compilation scheme,
called the <em>front-end</em>, maps the source code into IR, and the
second phase, called the <em>back-end</em>, maps IR into machine code.
That way, for each programming language you want to compile, you
write one front-end only, and for each computer architecture, you
write one back-end. So, totally you have <i>n</i> + <i>m</i> components.

</p><p>
But the above ideal separation of compilation into two phases does not
work very well for real programming languages and architectures.
Ideally, you must encode all knowledge about the source programming
language in the front end, you must handle all machine architecture
features in the back end, and you must design your IRs in such a way
that all language and machine features are captured properly.

</p><p>
A typical real-world compiler usually has multiple phases. This
increases the compiler's portability and simplifies retargeting.  The
front end consists of the following phases:

</p><ol>
<li><em>scanning</em>: a scanner groups input characters into tokens;
</li>
<li><em>parsing</em>: a parser recognizes sequences of tokens according to some grammar and generates
<em>Abstract Syntax Trees</em> (ASTs);
</li>
<li><em>Semantic analysis</em>: performs <em>type checking</em> (ie, checking
whether the variables, functions etc in the source program are used
consistently with their definitions and with the language semantics) and translates ASTs into IRs;
</li>
<li><em>optimization</em>: optimizes IRs.
</li>
</ol>
The back end consists of the following phases:

<ol>
<li><em>instruction selection</em>: maps IRs into assembly code;
</li>
<li><em>code optimization</em>: optimizes the assembly code using control-flow and data-flow analyses, register allocation, etc;
</li>
<li><em>code emission</em>: generates machine code from assembly code.
</li>
</ol>
The generated machine code is written in an object file. This file is not executable since it may refer to external symbols
(such as system calls).
The operating system provides the following utilities to execute the code:

<ol>
<li><em>linking</em>: A linker takes several object files and libraries as input and produces one executable object file.
It retrieves from the input files (and puts them together in the executable object file) the code of all
the referenced functions/procedures and it resolves all external references to real addresses.
The libraries include the operating sytem libraries, the language-specific libraries, and, maybe, user-created libraries.
</li>
<li><em>loading</em>: A loader loads an executable object file into memory, initializes the registers, heap, data, etc
and starts the execution of the program.
</li>
</ol>
Relocatable shared libraries allow effective memory use when many different applications share the same code.

<p>

</p><h1><a name="SECTION00030000000000000000">
2 Lexical Analysis</a>
</h1>

<p>
A <em>scanner</em> groups input characters into tokens. For example,
if the input is 
</p><pre>x = x*(b+1);
</pre>
then the scanner generates the following
sequence of tokens 
<pre>id(x)
=
id(x)
*
(
id(b)
+
num(1)
)
;
</pre>
where <code>id(x)</code> indicates the identifier with name <code>x</code> (a
program variable in this case) and <code>num(1)</code> indicates the integer
<code>1</code>. Each time the parser needs a token, it sends a request to
the scanner. Then, the scanner reads as many characters from the input
stream as it is necessary to construct a single token.  The scanner
may report an error during scanning (eg, when it finds an end-of-file
in the middle of a string). Otherwise, when a single token is formed,
the scanner is suspended and returns the token to the parser. The
parser will repeatedly call the scanner to read all the tokens from
the input stream or until an error is detected (such as a syntax
error).

<p>
Tokens are typically represented by numbers. For example, the token
<code>*</code> may be assigned number 35. Some tokens require some extra
information. For example, an identifier is a token (so it is
represented by some number) but it is also associated with a string
that holds the identifier name. For example, the token <code>id(x)</code> is
associated with the string, <code>"x"</code>. Similarly, the token
<code>num(1)</code> is associated with the number, 1.

</p><p>
Tokens are specified by patterns, called <em>regular expressions</em>.
For example, the regular expression <code>[a-z][a-zA-Z0-9]*</code>
recognizes all identifiers with at least one alphanumeric letter whose
first letter is lower-case alphabetic.

</p><p>
A typical scanner:

</p><ol>
<li>recognizes the <em>keywords</em> of the language (these are the 
reserved words that have a special meaning in the language, such as the word <code>class</code> in Java);
</li>
<li>recognizes special characters, such as <code>(</code> and <code>)</code>, or
groups of special characters, such as <code>:=</code> and <code>==</code>;
</li>
<li>recognizes identifiers, integers, reals, decimals, strings, etc;
</li>
<li>ignores whitespaces (tabs and blanks) and comments;
</li>
<li>recognizes and processes special directives (such as the <code>#include "file"</code>
directive in C) and macros.
</li>
</ol>

<p>
A key issue is speed. One can always write a naive scanner that groups
the input characters into lexical words (a lexical word can be either
a sequence of alphanumeric characters without whitespaces or special
characters, or just one special character), and then tries to
associate a token (ie. number, keyword, identifier, etc) to this
lexical word by performing a number of string comparisons.  This
becomes very expensive when there are many keywords and/or many
special lexical patterns in the language. In this section you will
learn how to build efficient scanners using regular expressions and
finite automata.  There are automated tools called <em>scanner
generators</em>, such as <em>flex</em> for C and <em>JLex</em> for Java, which
construct a fast scanner automatically according to specifications
(regular expressions).  You will first learn how to specify a scanner
using regular expressions, then the underlying theory that scanner
generators use to compile regular expressions into efficient programs
(which are basically finite state machines), and then you will learn
how to use a scanner generator for Java, called JLex.

</p><p>

</p><h2><a name="SECTION00031000000000000000">
2.1 Regular Expressions (REs)</a>
</h2>

<p>
Regular expressions are a very convenient form of representing
(possibly infinite) sets of strings, called <em>regular sets</em>. For
example, the RE (<i>a</i>| <i>b</i>)*<i>aa</i> represents the infinite set
<!-- MATH
 $\{``aa",``aaa",``baa",``abaa",\cdots\}$
 -->
{``<i>aa</i>",``<i>aaa</i>",``<i>baa</i>",``<i>abaa</i>",<sup> ... </sup>}, which is the set of all
strings with characters <i>a</i> and <i>b</i> that end in <i>aa</i>.  Formally, a RE
is one of the following (along with the set of strings it
designates):

</p><p>
<table border="1" cellpadding="3">
<tbody><tr><td align="RIGHT">name</td>
<td align="CENTER">RE</td>
<td align="LEFT">designation</td>
</tr>
<tr><td align="RIGHT">epsilon</td>
<td align="CENTER"><!-- MATH
 $\varepsilon$
 -->
<img src="compiler_files/img2.png" alt="$ \varepsilon$" align="BOTTOM" border="0" height="11" width="10"></td>
<td align="LEFT">{``"}</td>
</tr>
<tr><td align="RIGHT">symbol</td>
<td align="CENTER"><i>a</i></td>
<td align="LEFT">{``<i>a</i>"} for some character <i>a</i></td>
</tr>
<tr><td align="RIGHT">concatenation</td>
<td align="CENTER"><i>AB</i></td>
<td align="LEFT">the set <!-- MATH
 $\{\,rs|\,r\in {\cal A},\,s\in {\cal B}\,\}$
 -->
{&nbsp;<i>rs</i>|&nbsp;<i>r</i> <img src="compiler_files/img3.png" alt="$ \in$" align="MIDDLE" border="0" height="24" width="13"> <img src="compiler_files/img4.png" alt="$ \cal {A}$" align="BOTTOM" border="0" height="13" width="14">,&nbsp;<i>s</i> <img src="compiler_files/img3.png" alt="$ \in$" align="MIDDLE" border="0" height="24" width="13"> <img src="compiler_files/img5.png" alt="$ \cal {B}$" align="BOTTOM" border="0" height="12" width="13">&nbsp;}, where
<i>rs</i> is string</td>
</tr>
<tr><td align="RIGHT">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">concatenation, and <img src="compiler_files/img4.png" alt="$ \cal {A}$" align="BOTTOM" border="0" height="13" width="14"> and <img src="compiler_files/img5.png" alt="$ \cal {B}$" align="BOTTOM" border="0" height="12" width="13"> designate the REs <i>A</i> and <i>B</i></td>
</tr>
<tr><td align="RIGHT">alternation</td>
<td align="CENTER"><i>A</i>| <i>B</i></td>
<td align="LEFT">the set <!-- MATH
 ${\cal A}\cup {\cal B}$
 -->
<img src="compiler_files/img4.png" alt="$ \cal {A}$" align="BOTTOM" border="0" height="13" width="14"> <img src="compiler_files/img6.png" alt="$ \cup$" align="BOTTOM" border="0" height="11" width="13"> <img src="compiler_files/img5.png" alt="$ \cal {B}$" align="BOTTOM" border="0" height="12" width="13">, where <img src="compiler_files/img4.png" alt="$ \cal {A}$" align="BOTTOM" border="0" height="13" width="14"> and <img src="compiler_files/img5.png" alt="$ \cal {B}$" align="BOTTOM" border="0" height="12" width="13"> designate the REs <i>A</i> and <i>B</i></td>
</tr>
<tr><td align="RIGHT">repetition</td>
<td align="CENTER"><i>A</i><sup>*</sup></td>
<td align="LEFT">the set <!-- MATH
 $\epsilon |A| (AA)| (AAA)|\cdots$
 -->
<img src="compiler_files/img7.png" alt="$ \epsilon$" align="BOTTOM" border="0" height="11" width="9">| <i>A</i>|(<i>AA</i>)|(<i>AAA</i>)|<sup> ... </sup> (an infinite set)</td>
</tr>
</tbody></table>

</p><p>
Repetition is also called Kleen closure.
For example, (<i>a</i>| <i>b</i>)<i>c</i> designates the set <!-- MATH
 $\{\,rs|\,r\in (\{``a"\}\cup\{``b"\}),\,s\in \{``c"\}\,\}$
 -->
{&nbsp;<i>rs</i>|&nbsp;<i>r</i> <img src="compiler_files/img3.png" alt="$ \in$" align="MIDDLE" border="0" height="24" width="13"> ({``<i>a</i>"} <img src="compiler_files/img6.png" alt="$ \cup$" align="BOTTOM" border="0" height="11" width="13"> {``<i>b</i>"}),&nbsp;<i>s</i> <img src="compiler_files/img3.png" alt="$ \in$" align="MIDDLE" border="0" height="24" width="13"> {``<i>c</i>"}&nbsp;},
which is equal to <!-- MATH
 $\{``ac",``bc"\}$
 -->
{``<i>ac</i>",``<i>bc</i>"}.

</p><p>
We will use the following notational conveniences:

</p><p>
<!-- MATH
 \begin{displaymath}
\begin{array}{lcl}
P^+ & = & PP^*\\
P? & = & P\,|\,\varepsilon\\
\/[ a-z ] & = & a|b|c|\cdots|z
\end{array}
\end{displaymath}
 -->
</p><p></p>
<div align="CENTER">
<table>
<tbody><tr valign="MIDDLE"><td align="LEFT"><i>P</i><sup>+</sup></td>
<td align="CENTER">=</td>
<td align="LEFT"><i>PP</i><sup>*</sup></td>
</tr>
<tr valign="MIDDLE"><td align="LEFT"><i>P</i>?</td>
<td align="CENTER">=</td>
<td align="LEFT"><i>P</i>&nbsp;|&nbsp;<img src="compiler_files/img8.png" alt="$\displaystyle \varepsilon$" align="MIDDLE" border="0" height="24" width="10"></td>
</tr>
<tr valign="MIDDLE"><td align="LEFT">[<i>a</i> - <i>z</i>]</td>
<td align="CENTER">=</td>
<td align="LEFT"><i>a</i>| <i>b</i>| <i>c</i>|<sup> ... </sup>| <i>z</i></td>
</tr>
</tbody></table>
</div><p></p>

<p>
We can freely put parentheses around REs to denote the order of
evaluation.  For example, (<i>a</i>| <i>b</i>)<i>c</i>. To avoid using many parentheses,
we use the following rules: concatenation and alternation are
associative (ie, <i>ABC</i> means (<i>AB</i>)<i>C</i> and is equivalent to <i>A</i>(<i>BC</i>)),
alternation is commutative (ie, <i>A</i>| <i>B</i> = <i>B</i>| <i>A</i>), repetition is
idempotent (ie, <!-- MATH
 $A^{**}=A^*$
 -->
<i>A</i><sup>**</sup> = <i>A</i><sup>*</sup>), and concatenation distributes
over alternation (eg, <!-- MATH
 $(a|b)c=ac|bc$
 -->
(<i>a</i>| <i>b</i>)<i>c</i> = <i>ac</i>| <i>bc</i>).

</p><p>
For convenience, we can give names to REs so we can refer to them by their name. For example:

</p><p>
<!-- MATH
 \begin{displaymath}
\begin{array}{lcl}
for-keyword & = & for\\
letter & = & [a-zA-Z]\\
digit & = & [0-9]\\
identifier & = & letter\, (letter\,|\,digit)^*\\
sign & = & +|-|\,\varepsilon\\
integer & = & sign\,(0\,|\,[1-9]digit^*)\\
decimal & = & integer\, .\, digit^*\\
real & = & (integer\,|\,decimal)\,E\, sign\, digit^+
\end{array}
\end{displaymath}
 -->
</p><p></p>
<div align="CENTER">
<table>
<tbody><tr valign="MIDDLE"><td align="LEFT"><i>for</i> - <i>keyword</i></td>
<td align="CENTER">=</td>
<td align="LEFT"><i>for</i></td>
</tr>
<tr valign="MIDDLE"><td align="LEFT"><i>letter</i></td>
<td align="CENTER">=</td>
<td align="LEFT">[<i>a</i> - <i>zA</i> - <i>Z</i>]</td>
</tr>
<tr valign="MIDDLE"><td align="LEFT"><i>digit</i></td>
<td align="CENTER">=</td>
<td align="LEFT">[0 - 9]</td>
</tr>
<tr valign="MIDDLE"><td align="LEFT"><i>identifier</i></td>
<td align="CENTER">=</td>
<td align="LEFT"><i>letter</i>&nbsp;(<i>letter</i>&nbsp;|&nbsp;<i>digit</i>)<sup>*</sup></td>
</tr>
<tr valign="MIDDLE"><td align="LEFT"><i>sign</i></td>
<td align="CENTER">=</td>
<td align="LEFT">+ | - |&nbsp;<img src="compiler_files/img8.png" alt="$\displaystyle \varepsilon$" align="MIDDLE" border="0" height="24" width="10"></td>
</tr>
<tr valign="MIDDLE"><td align="LEFT"><i>integer</i></td>
<td align="CENTER">=</td>
<td align="LEFT"><i>sign</i>&nbsp;(0&nbsp;|&nbsp;[1 - 9]<i>digit</i><sup>*</sup>)</td>
</tr>
<tr valign="MIDDLE"><td align="LEFT"><i>decimal</i></td>
<td align="CENTER">=</td>
<td align="LEFT"><i>integer</i>&nbsp;.&nbsp;<i>digit</i><sup>*</sup></td>
</tr>
<tr valign="MIDDLE"><td align="LEFT"><i>real</i></td>
<td align="CENTER">=</td>
<td align="LEFT">(<i>integer</i>&nbsp;|&nbsp;<i>decimal</i> )&nbsp;<i>E</i>&nbsp;<i>sign</i>&nbsp;<i>digit</i><sup>+</sup></td>
</tr>
</tbody></table>
</div><p></p>

<p>
There is some ambiguity though: If the input includes the characters
<code>for8</code>, then the first rule (for <em>for-keyword</em>) matches 3
characters (<code>for</code>), the fourth rule (for <em>identifier</em>) can
match 1, 2, 3, or 4 characters, the longest being <code>for8</code>.  To
resolve this type of ambiguities, when there is a choice of rules,
scanner generators choose the one that matches the maximum number of
characters. In this case, the chosen rule is the one for <em>identifier</em> that matches 4 characters (<code>for8</code>).  This
disambiguation rule is called the <em>longest match rule</em>. If there
are more than one rules that match the same maximum number of
characters, the rule listed first is chosen. This is the <em>rule
priority</em> disambiguation rule.  For example, the lexical word
<code>for</code> is taken as a <em>for-keyword</em> even though it uses the
same number of characters as an identifier.

</p><p>

</p><h2><a name="SECTION00032000000000000000">
2.2 Deterministic Finite Automata (DFAs)</a>
</h2>

<p>
A DFA represents a finite state machine that recognizes a RE.
For example, the following DFA:

</p><p>
<img src="compiler_files/dfa1.gif" alt="dfa1.gif" align="BOTTOM" border="0" height="87" width="363">

</p><p>
recognizes (<i>abc</i><sup>+</sup>)<sup>+</sup>. A finite automaton consists of a finite set of
states, a set of transitions (moves), one start state, and a set of
final states (accepting states). In addition, a DFA has a unique
transition for every state-character combination.  
For example, the previous figure has 4 states, state 1 is the start state,
and state 4 is the only final state.

</p><p>
A DFA accepts a string if starting from the start state and moving
from state to state, each time following the arrow that corresponds
the current input character, it reaches a final state when the entire
input string is consumed. Otherwise, it rejects the string.

</p><p>
The previous figure represents a DFA even though it is not complete (ie,
not all state-character transitions have been drawn).
The complete DFA is:

</p><p>
<img src="compiler_files/dfa2.gif" alt="dfa2.gif" align="BOTTOM" border="0" height="182" width="363">

</p><p>
but it is very common to ignore state 0 (called the <em>error state</em>) since
it is implied. (The arrows with two or more characters indicate
transitions in case of any of these characters.) The error state serves as a black hole,
which doesn't let you escape.

</p><p>
A DFA is represented by a <em>transition table</em> <i>T</i>, which gives the next
state <i>T</i>[<i>s</i>, <i>c</i>] for a state <i>s</i> and a character <i>c</i>.
For example, the <i>T</i> for the DFA above is:

</p><p>
<table border="1" cellpadding="3">
<tbody><tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">a</td>
<td align="LEFT">b</td>
<td align="LEFT">c</td>
</tr>
<tr><td align="LEFT">0</td>
<td align="LEFT">0</td>
<td align="LEFT">0</td>
<td align="LEFT">0</td>
</tr>
<tr><td align="LEFT">1</td>
<td align="LEFT">2</td>
<td align="LEFT">0</td>
<td align="LEFT">0</td>
</tr>
<tr><td align="LEFT">2</td>
<td align="LEFT">0</td>
<td align="LEFT">3</td>
<td align="LEFT">0</td>
</tr>
<tr><td align="LEFT">3</td>
<td align="LEFT">0</td>
<td align="LEFT">0</td>
<td align="LEFT">4</td>
</tr>
<tr><td align="LEFT">4</td>
<td align="LEFT">2</td>
<td align="LEFT">0</td>
<td align="LEFT">4</td>
</tr>
</tbody></table>

</p><p>
Suppose that we want to build a scanner for the REs:

</p><p>
<!-- MATH
 \begin{displaymath}
\begin{array}{lcl}
for-keyword & = & for\\
identifier & = & [a-z][a-z0-9]^*
\end{array}
\end{displaymath}
 -->
</p><p></p>
<div align="CENTER">
<table>
<tbody><tr valign="MIDDLE"><td align="LEFT"><i>for</i> - <i>keyword</i></td>
<td align="CENTER">=</td>
<td align="LEFT"><i>for</i></td>
</tr>
<tr valign="MIDDLE"><td align="LEFT"><i>identifier</i></td>
<td align="CENTER">=</td>
<td align="LEFT">[<i>a</i> - <i>z</i>][<i>a</i> - <i>z</i>0 - 9]<sup>*</sup></td>
</tr>
</tbody></table>
</div><p></p>

<p>
The corresponding DFA has 4 final states: one to accept the <em>for-keyword</em> and
3 to accept an identifier:

</p><p>
<img src="compiler_files/dfa3.gif" alt="dfa3.gif" align="BOTTOM" border="0" height="211" width="458">

</p><p>

(the error state is omitted again). Notice that for each state and for
each character, there is a single transition.

</p><p>
A scanner based on a DFA uses the DFA's transition table as follows:

</p><p>
</p><pre>state = initial_state;
current_character = get_next_character();
while ( true )
{   next_state = T[state,current_character];
    if (next_state == ERROR)
       break;
    state = next_state;
    current_character = get_next_character();
    if ( current_character == EOF )
       break;
};
if ( is_final_state(state) )
   `we have a valid token'
else `report an error'
</pre>

<p>
This program does not explicitly take into account the longest match 
disambiguation rule since it ends at EOF.  The following program
is more general since it does not expect EOF at the end of token but 
still uses the longest match disambiguation rule.

</p><p>
</p><pre>state = initial_state;
final_state = ERROR;
current_character = get_next_character();
while ( true )
{   next_state = T[state,current_character];
    if (next_state == ERROR)
       break;
    state = next_state;
    if ( is_final_state(state) )
       final_state = state;
    current_character = get_next_character();
    if (current_character == EOF)
       break;
};
if ( final_state == ERROR )
   `report an error'
else if ( state != final_state )
   `we have a valid token but we need to backtrack
         (to put characters back into the input stream)'
else `we have a valid token'
</pre>

<p>
Is there any better (more efficient) way to build a scanner out of a
DFA?  Yes! We can hardwire the state transition table into a program
(with lots of gotos). You've learned in your programming language
course never to use gotos.  But here we are talking about a program
generated automatically, which no one needs to look at. The idea is
the following. Suppose that you have a transition from state <i>s</i><sub>1</sub> to
<i>s</i><sub>2</sub> when the current character is <i>c</i>. Then you generate the program:

</p><p>
</p><pre>s1: current_character = get_next_character();
    ...
    if ( current_character == 'c' )
       goto s2;
    ...
s2: current_character = get_next_character();
    ...
</pre>

<p>

</p><h2><a name="SECTION00033000000000000000"></a><a name="convert"></a>
<br>
2.3 Converting a Regular Expression into a Deterministic Finite Automaton
</h2>

<p>
The task of a scanner generator, such as JLex, is to generate the
transition tables or to synthesize the scanner program given a scanner
specification (in the form of a set of REs).  So it needs to convert
REs into a single DFA. This is accomplished in two steps: first it
converts REs into a non-deterministic finite automaton (NFA) and then
it converts the NFA into a DFA.

</p><p>
An NFA is similar to a DFA but it also permits multiple transitions
over the same character and transitions over <!-- MATH
 $\varepsilon$
 -->
<img src="compiler_files/img2.png" alt="$ \varepsilon$" align="BOTTOM" border="0" height="11" width="10">. In the
case of multiple transitions from a state over the same character,
when we are at this state and we read this character, we have more
than one choice; the NFA succeeds if at least one of these choices
succeeds. The <!-- MATH
 $\varepsilon$
 -->
<img src="compiler_files/img2.png" alt="$ \varepsilon$" align="BOTTOM" border="0" height="11" width="10"> transition doesn't consume any input
characters, so you may jump to another state for free.

</p><p>
Clearly DFAs are a subset of NFAs. But it turns out that DFAs and NFAs
have the same expressive power. The problem is that when converting
a NFA to a DFA we may get an exponential blowup in the number of
states. 

</p><p>
We will first learn how to convert a RE into a NFA. This is the easy part.
There are only 5 rules, one for each type of RE:

</p><p>
<img src="compiler_files/dfa4.gif" alt="dfa4.gif" align="BOTTOM" border="0" height="314" width="367">

</p><p>
As it can been shown inductively, the above rules construct NFAs with
only one final state.  For example, the third rule indicates that, to
construct the NFA for the RE <i>AB</i>, we construct the NFAs for <i>A</i> and
<i>B</i>, which are represented as two boxes with one start state and one
final state for each box. Then the NFA for <i>AB</i> is constructed by
connecting the final state of <i>A</i> to the start state of <i>B</i> using an
empty transition.

</p><p>
For example, the RE (<i>a</i>| <i>b</i>)<i>c</i> is mapped to the following NFA:

</p><p>
<img src="compiler_files/dfa10.gif" alt="dfa10.gif" align="BOTTOM" border="0" height="127" width="393">

</p><p>
The next step is to convert a NFA to a DFA (called <em>subset
construction</em>). Suppose that you assign a number to each NFA state.
The DFA states generated by subset construction have sets of numbers,
instead of just one number. For example, a DFA state may have been
assigned the set {5, 6, 8}. This indicates that arriving to the
state labeled {5, 6, 8} in the DFA is the same as arriving to the
state 5, the state 6, or the state 8 in the NFA when parsing the same
input. (Recall that a particular input sequence when parsed by a DFA,
leads to a unique state, while when parsed by a NFA it may lead to
multiple states.) 

</p><p>
First we need to handle transitions that lead to other states for free
(without consuming any input). These are the <!-- MATH
 $\varepsilon$
 -->
<img src="compiler_files/img2.png" alt="$ \varepsilon$" align="BOTTOM" border="0" height="11" width="10">
transitions.  We define the <em>closure</em> of a NFA node as the set of
all the nodes reachable by this node using zero, one, or more <!-- MATH
 $\varepsilon$
 -->
<img src="compiler_files/img2.png" alt="$ \varepsilon$" align="BOTTOM" border="0" height="11" width="10">
transitions. For example, The closure of node 1 in the left figure
below

</p><p>
<img src="compiler_files/dfa5.gif" alt="dfa5.gif" align="BOTTOM" border="0" height="150" width="610">

</p><p>
is the set {1, 2}. The start state of the constructed DFA is
labeled by the closure of the NFA start state. For every DFA state
labeled by some set <!-- MATH
 $\{s_1,\ldots,s_n\}$
 -->
{<i>s</i><sub>1</sub>,..., <i>s</i><sub>n</sub>} and for every character <i>c</i>
in the language alphabet, you find all the states reachable by <i>s</i><sub>1</sub>,
<i>s</i><sub>2</sub>, ..., or <i>s</i><sub>n</sub> using <i>c</i> arrows and you union together the
closures of these nodes. If this set is not the label of any other
node in the DFA constructed so far, you create a new DFA node with
this label.  For example, node {1, 2} in the DFA above has an arrow
to a {3, 4, 5} for the character <i>a</i> since the NFA node 3 can be
reached by 1 on <i>a</i> and nodes 4 and 5 can be reached by 2.  The <i>b</i>
arrow for node {1, 2} goes to the error node which is associated
with an empty set of NFA nodes.

</p><p>
The following NFA recognizes <!-- MATH
 $(a|b)^*(abb\,|\,a^+b)$
 -->
(<i>a</i>| <i>b</i>)<sup>*</sup>(<i>abb</i>&nbsp;|&nbsp;<i>a</i><sup>+</sup><i>b</i>),
even though it wasn't constructed with the above RE-to-NFA rules.
It has the following DFA:

</p><p>
<img src="compiler_files/dfa6.gif" alt="dfa6.gif" align="BOTTOM" border="0" height="164" width="762">

</p><p>

</p><h2><a name="SECTION00034000000000000000">
2.4 Case Study: The Calculator Scanner</a>
</h2>

<p>
As a running example for this and the subsequent sections,
we will use a simple interpreter for a calculator written in Java.
If you don't have Java on your PC, you need to download Sun's J2SE SDK from
<a name="tex2html1" href="http://java.sun.com/j2se/downloads.html">http://java.sun.com/j2se/downloads.html</a>.
You also need to download 

</p><ol>
<li>the jar archive that contains the CUP, JLex, and Gen classes from
<a name="tex2html2" href="http://lambda.uta.edu/System.jar">http://lambda.uta.edu/System.jar</a>
</li>
<li>the file <a name="tex2html3" href="http://lambda.uta.edu/cse5317/calc.tar.gz">http://lambda.uta.edu/cse5317/calc.tar.gz</a>
</li>
</ol>
On a Unix system, you do:

<ol>
<li>execute: <code>tar xfz calc.tar.gz</code> to extract the files in the directory <code>calc</code>
</li>
<li>change the CLASSPATH line in the file <code>calc/Makefile</code> to point to your System.jar
</li>
<li>execute: <code>cd calc; build</code>
</li>
<li>run the calculator using <code>run</code>
</li>
</ol>
On Windows, you do:

<ol>
<li>uncompress and extract the files from <code>tar xfz calc.tar.gz</code>
</li>
<li>change the <code>make.bat</code> and <code>run.bat</code> files to point to your jar files
</li>
<li>on a DOS prompt go to the <code>calc</code> directory and do <code>build</code> to compile the programs
</li>
<li>do a <code>run</code> to run the calculator
</li>
</ol>
Using the calculator, you can calculate arithmetic expressions, such as
<code>2*(3+8);</code>, you can assign values to variables, such as
<code>x:=3+4;</code>, you can reference variables by name, such as
<code>x+3;</code>, you can define recursive functions interactively, such as
<code>define f(n) = if n=0 then 1 else n*f(n-1);</code>, and you can call them
using <code>f(5);</code>, etc. You exit using <code>quit;</code>.

<p>
The source files of the calculator example are given in
<a name="tex2html4" href="http://lambda.uta.edu/cse5317/calc/">http://lambda.uta.edu/cse5317/calc/</a>.
Some of these files will be explained
in detail later, but now we are ready to look at the scanner only, given
in <a name="tex2html5" href="http://lambda.uta.edu/cse5317/calc/calc.lex">calc.lex</a>.  The tokens, such
as <code>sym.INT</code>, are imported from the
<a name="tex2html6" href="http://lambda.uta.edu/cse5317/calc/simple_calc.cup">parser</a>
and will be explained
in the next section.  For now, just assume that these are different constants
(integers). The order of lines is important in some cases: if we put
the rule for <code>{ID}</code> before the keywords, then the keywords will
never be recognized (this is the consequence of the rule priority
law).  The lexical constructs that need to be skipped, such as
comments and whitespaces, should never return (we must return only
when we find a complete token).

</p><p>

</p><h1><a name="SECTION00040000000000000000">
3 Parsing</a>
</h1>

<p>

</p><h2><a name="SECTION00041000000000000000">
3.1 Context-free Grammars</a>
</h2>

<p>
Consider the following input string:
</p><pre>x+2*y
</pre>
When scanned by a scanner, it produces the following stream of tokens:
<pre>id(x)
+
num(2)
*
id(y)
</pre>
The goal is to parse this expression and construct a data structure (a
parse tree) to represent it. One possible syntax for expressions is
given by the following grammar G1:
<pre>E ::= E + T
    | E - T
    | T
T ::= T * F
    | T / F
    | F
F ::= num
    | id
</pre>
where <code>E, T</code> and <code>F</code> stand for expression, term, and factor respectively.
For example, the rule for <code>E</code> indicates that an expression <code>E</code>
can take one of the following 3 forms: an expression followed by the token
<code>+</code> followed by a term, or an expression followed by the token
<code>-</code> followed by a term, or simply a term. The first rule for <code>E</code> is actually
a shorthand of 3 productions:
<pre>E ::= E + T
E ::= E - T
E ::= T
</pre>
G1 is an example of a context-free grammar (defined below); the
symbols <code>E, T</code> and <code>F</code> are <em>nonterminals</em> and should be
defined using production rules, while <code>+, -, *, /, num</code>, and
<code>id</code> are <em>terminals</em> (ie, tokens) produced by the scanner.
The nonterminal <code>E</code> is the <em>start symbol</em> of the grammar.

<p>
In general, a <em>context-free grammar</em> (CFG) has a finite set of terminals (tokens),
a finite set of nonterminals from which one is the start symbol,
and a finite set of <em>productions</em> of the form:
</p><pre>A ::= X1 X2 ... Xn
</pre>
where <code>A</code> is a nonterminal and each <code>Xi</code> is either a terminal or nonterminal symbol.

<p>
Given two sequences of symbols <i>a</i> and <i>b</i> (can be any combination of
terminals and nonterminals) and a production <!-- MATH
 $A ::= X_1 X_2 ... X_n$
 -->
<i>A</i> : : = <i>X</i><sub>1</sub><i>X</i><sub>2</sub>...<i>X</i><sub>n</sub>,
the form <!-- MATH
 $aAb => aX_1 X_2 ... X_nb$
 -->
<i>aAb</i> = &gt; <i>aX</i><sub>1</sub><i>X</i><sub>2</sub>...<i>X</i><sub>n</sub><i>b</i> is called a <em>derivation</em>. That
is, the nonterminal symbol <i>A</i> is replaced by the rhs
(right-hand-side) of the production for <i>A</i>. For example,
</p><pre>T / F + 1 - x =&gt; T * F / F + 1 - x
</pre>
is a derivation since we used the production <code>T := T * F</code>.

<p>
<em>Top-down parsing</em> starts from the start symbol of the grammar <i>S</i> and
applies derivations until the entire input string is derived (ie, a
sequence of terminals that matches the input tokens). For example,
</p><pre>E =&gt; E + T
  =&gt; E + T * F
  =&gt; T + T * F
  =&gt; T + F * F
  =&gt; T + num * F
  =&gt; F + num * F
  =&gt; id + num * F
  =&gt; id + num * id
</pre>
which matches the input sequence <code>id(x) + num(2) * id(y)</code>.  Top
down parsing occasionally requires backtracking.  For example, suppose
the we used the derivation <code>E =&gt; E - T</code> instead of the first
derivation. Then, later we would have to backtrack because the derived
symbols will not match the input tokens. This is true for all
nonterminals that have more than one production since it indicates
that there is a choice of which production to use. We will learn how
to construct parsers for many types of CFGs that never backtrack. These
parsers are based on a method called <em>predictive parsing</em>. One
issue to consider is which nonterminal to replace when there is a
choice. For example, in <code>T + F * F</code> we have 3 choices: we can use
a derivation for <code>T</code>, for the first <code>F</code>, or for the second
<code>F</code>. When we always replace the leftmost nonterminal, it is
called <em>leftmost derivation</em>.

<p>
In contrast to top-down parsing, <em>bottom-up parsing</em> starts from
the input string and uses derivations in the opposite directions (ie,
by replacing the rhs sequence <!-- MATH
 $X_1 X_2 ... X_n$
 -->
<i>X</i><sub>1</sub><i>X</i><sub>2</sub>...<i>X</i><sub>n</sub> of a production <!-- MATH
 $A ::=
X_1 X_2 ... X_n$
 -->
<i>A</i> : : = <i>X</i><sub>1</sub><i>X</i><sub>2</sub>...<i>X</i><sub>n</sub> with the nonterminal <i>A</i>. It stops when it derives the
start symbol. For example,
</p><pre>   id(x) + num(2) * id(y)
=&gt; id(x) + num(2) * F
=&gt; id(x) + F * F
=&gt; id(x) + T * F
=&gt; id(x) + T
=&gt; F + T
=&gt; T + T
=&gt; E + T
=&gt; E
</pre>

<p>
The <em>parse tree</em> of an input sequence according to a CFG is the
tree of derivations.  For example if we used a production <!-- MATH
 $A ::= X_1
X_2 ... X_n$
 -->
<i>A</i> : : = <i>X</i><sub>1</sub><i>X</i><sub>2</sub>...<i>X</i><sub>n</sub> (in either top-down or bottom-up parsing) then we
construct a tree with node <i>A</i> and children <!-- MATH
 $X_1 X_2 ... X_n$
 -->
<i>X</i><sub>1</sub><i>X</i><sub>2</sub>...<i>X</i><sub>n</sub>.
For example, the parse tree of <code>id(x) + num(2) * id(y)</code> is:
</p><pre>        E
     /  |   \
   E    +     T
   |       /  |  \
   T       T  *   F
   |       |      |
   F       F      id
   |       |
   id     num
</pre>
So a parse tree has non-terminals for internal nodes and terminals
for leaves.
As another example, consider the following grammar:
<pre>S ::= ( L )
    | a
L ::= L , S
    | S
</pre>
Under this grammar,
the parse tree of the sentence <!-- MATH
 $(a,((a,a),a))$
 -->
(<i>a</i>,((<i>a</i>, <i>a</i>), <i>a</i>)) is:
<pre>         S
      /  |  \
     (   L   )
       / | \
      L  ,  S
      |   / | \
      S  (  L  )
      |   / | \
      a  L  ,  S
         |     |
         S     a
      /  |  \
     (   L   )
       / | \
      L  ,  S
      |     |
      S     a
      |
      a
</pre>

<p>
Consider now the following grammar G2:
</p><pre>E ::= T + E
    | T - E
    | T
T ::= F * T
    | F / T
    | F
F ::= num
    | id
</pre>
This is similar to our original grammar, but it is right associative
when the leftmost derivation rules is used. That is,
<code>x-y-z</code> is equivalent to <code>x-(y-z)</code> under G2, as we can see from
its parse tree.

<p>
Consider now the following grammar G3:
</p><pre>E ::= E + E
    | E - E
    | E * E
    | E / E
    | num
    | id
</pre>
Is this grammar equivalent to our original grammar G1? Well, it
recognizes the same language, but it constructs the wrong parse trees.
For example, the <code>x+y*z</code> is interpreted as <code>(x+y)*z</code> by this
grammar (if we use leftmost derivations) and as <code>x+(y*z)</code> by G1
or G2. That is, both G1 and G2 grammar handle the operator
precedence correctly (since * has higher precedence than +), while
the G3 grammar does not. 

<p>
In general, to write a grammar that handles
precedence properly, we can start with a grammar that does not handle
precedence at all, such as our last grammar G3, and then we can refine
it by creating more nonterminals, one for each group of operators that
have the same precedence. For example, suppose we want to parse
an expression <i>E</i> and we have 4 groups of operators: {<i>not</i>},
{*,/}, { + , - }, and <!-- MATH
 $\{and,or\}$
 -->
{<i>and</i>, <i>or</i>}, in this order of
precedence. Then we create 4 new nonterminals: <i>N</i>, <i>T</i>, <i>F</i>, and <i>B</i>
and we split the derivations for <i>E</i> into 5 groups of derivations (the
same way we split the rules for <i>E</i> in the last grammar into 3 groups
in the first grammar).

</p><p>
A grammar is <em>ambiguous</em> if it has more than one parse tree for
the same input sequence depending which derivations are applied each
time. For example, the grammar G3 is ambiguous since it has two
parse trees for <code>x-y-z</code> (one parses <code>x-y</code> first, while the
other parses <code>y-z</code> first). Of course, the first one is the right
interpretation since - is left associative. Fortunately, if we
always apply the leftmost derivation rule, we will never derive the
second parse tree. So in this case the leftmost derivation rule
removes the ambiguity.

</p><p>

</p><h2><a name="SECTION00042000000000000000">
3.2 Predictive Parsing</a>
</h2>

<p>
The goal of predictive parsing is to construct a top-down parser that never backtracks.
To do so, we must transform a grammar in two ways:

</p><ol>
<li>eliminate left recursion, and
</li>
<li>perform left factoring.
</li>
</ol>
These rules eliminate most common causes for backtracking although they do not guarantee
a completely backtrack-free parsing (called LL(1) as we will see later).

<p>
Consider this grammar:
</p><pre>A ::= A a
    | b
</pre>
It recognizes the regular expression <i>ba</i><sup>*</sup>. The problem is that if we use the first
production for top-down derivation, we will fall into an infinite
derivation chain. This is called <em>left recursion</em>. But how else
can you express <i>ba</i><sup>*</sup>? Here is an alternative way:
<pre>A ::= b A'
A' ::= a A'
     |
</pre>
where the third production is an empty production (ie, it is
<code>A' ::= </code>). That is, <i>A'</i> parses the RE <i>a</i><sup>*</sup>. Even though this
CFG is recursive, it is not left recursive. In general, for each
nonterminal <i>X</i>, we partition the productions for <i>X</i> into two groups:
one that contains the left recursive productions, and the other with
the rest. Suppose that the first group is:
<pre>X ::= X a1
...
X ::= X an
</pre>
while the second group is:
<pre>X ::= b1
...
X ::= bm
</pre>
where <code>a, b</code> are symbol sequences.
Then we eliminate the left recursion by rewriting these rules into:
<pre>X ::= b1 X'
...
X ::= bm X'
X' ::= a1 X'
...
X' ::= an X'
X' ::=
</pre>
For example, the CFG G1 is transformed into:
<pre>E ::= T E'
E' ::= + T E'
     | - T E'
     |
T ::= F T'
T' ::= * F T'
     | / F T'
     |
F ::= num
    | id
</pre>

<p>
Suppose now that we have a number of productions for <i>X</i> that have a
common prefix in their rhs (but without any left recursion):
</p><pre>X ::= a b1
...
X ::= a bn
</pre>
We factor out the common prefix as follows:
<pre>X ::= a X'
X' ::= b1
...
X' ::= bn
</pre>
This is called <em>left factoring</em> and it helps predict which rule to use without backtracking.
For example, the rule from our right associative grammar G2:
<pre>E ::= T + E
    | T - E
    | T
</pre>
is translated into:
<pre>E ::= T E'
E' ::= + E
     | - E
     |
</pre>

<p>
As another example,
let <i>L</i> be the language of all regular expressions over the alphabet <!-- MATH
 $\Sigma=\{a,b\}$
 -->
<img src="compiler_files/img9.png" alt="$ \Sigma$" align="BOTTOM" border="0" height="12" width="13"> = {<i>a</i>, <i>b</i>}.
That is, <!-- MATH
 $L=\{``\varepsilon",``a",``b",``a*",``b*",``a|b",``(a|b)",...\}$
 -->
<i>L</i> = {``<img src="compiler_files/img2.png" alt="$ \varepsilon$" align="BOTTOM" border="0" height="11" width="10">",``<i>a</i>",``<i>b</i>",``<i>a</i>*",``<i>b</i>*",``<i>a</i>| <i>b</i>",``(<i>a</i>| <i>b</i>)",...}.
For example, the string <!-- MATH
 $``a(a|b)*|b*"$
 -->
``<i>a</i>(<i>a</i>| <i>b</i>)*| <i>b</i>*" is a member of <i>L</i>.
There is no RE that captures the syntax of all REs.
Consider for example the RE <!-- MATH
 $((\cdots(a)\cdots))$
 -->
((<sup> ... </sup>(<i>a</i>)<sup> ... </sup>)), which is equivalent to the language 
(<sup>n</sup><i>a</i>)<sup>n</sup> for all <i>n</i>. This represents a valid RE but there is no RE that can capture its
syntax.
A context-free grammar that recognizes <i>L</i> is:
<!-- MATH
 \begin{displaymath}
\begin{array}{lrl}
R & ::= & R\, R\\
& | & R\,``|"\,R\\
& | & R\,*\\
& | & (\, R\,)\\
& | & a\\
& | & b\\
& | & ``\varepsilon"
\end{array}
\end{displaymath}
 -->
</p><p></p>
<div align="CENTER">
<table>
<tbody><tr valign="MIDDLE"><td align="LEFT"><i>R</i></td>
<td align="RIGHT">: : =</td>
<td align="LEFT"><i>R</i>&nbsp;<i>R</i></td>
</tr>
<tr valign="MIDDLE"><td align="LEFT">&nbsp;</td>
<td align="RIGHT">|</td>
<td align="LEFT"><i>R</i>&nbsp;``|"&nbsp;<i>R</i></td>
</tr>
<tr valign="MIDDLE"><td align="LEFT">&nbsp;</td>
<td align="RIGHT">|</td>
<td align="LEFT"><i>R</i>&nbsp;*</td>
</tr>
<tr valign="MIDDLE"><td align="LEFT">&nbsp;</td>
<td align="RIGHT">|</td>
<td align="LEFT">(&nbsp;<i>R</i>&nbsp;)</td>
</tr>
<tr valign="MIDDLE"><td align="LEFT">&nbsp;</td>
<td align="RIGHT">|</td>
<td align="LEFT"><i>a</i></td>
</tr>
<tr valign="MIDDLE"><td align="LEFT">&nbsp;</td>
<td align="RIGHT">|</td>
<td align="LEFT"><i>b</i></td>
</tr>
<tr valign="MIDDLE"><td align="LEFT">&nbsp;</td>
<td align="RIGHT">|</td>
<td align="LEFT">``<img src="compiler_files/img8.png" alt="$\displaystyle \varepsilon$" align="MIDDLE" border="0" height="24" width="10">"</td>
</tr>
</tbody></table>
</div><p></p>
after elimination of left recursion, this grammar becomes:
<!-- MATH
 \begin{displaymath}
\begin{array}{lrl}
R & ::= & (\, R\,)\,R'\\
& | & a\,R'\\
& | & b\,R'\\
& | & ``\varepsilon"\,R'\\
R' & ::= & R\,R'\\
& | & ``|"\,R\, R'\\
& | & *\,R'\\
& | &
\end{array}
\end{displaymath}
 -->
<p></p>
<div align="CENTER">
<table>
<tbody><tr valign="MIDDLE"><td align="LEFT"><i>R</i></td>
<td align="RIGHT">: : =</td>
<td align="LEFT">(&nbsp;<i>R</i>&nbsp;)&nbsp;<i>R'</i></td>
</tr>
<tr valign="MIDDLE"><td align="LEFT">&nbsp;</td>
<td align="RIGHT">|</td>
<td align="LEFT"><i>a</i>&nbsp;<i>R'</i></td>
</tr>
<tr valign="MIDDLE"><td align="LEFT">&nbsp;</td>
<td align="RIGHT">|</td>
<td align="LEFT"><i>b</i>&nbsp;<i>R'</i></td>
</tr>
<tr valign="MIDDLE"><td align="LEFT">&nbsp;</td>
<td align="RIGHT">|</td>
<td align="LEFT">``<img src="compiler_files/img8.png" alt="$\displaystyle \varepsilon$" align="MIDDLE" border="0" height="24" width="10">"&nbsp;<i>R'</i></td>
</tr>
<tr valign="MIDDLE"><td align="LEFT"><i>R'</i></td>
<td align="RIGHT">: : =</td>
<td align="LEFT"><i>R</i>&nbsp;<i>R'</i></td>
</tr>
<tr valign="MIDDLE"><td align="LEFT">&nbsp;</td>
<td align="RIGHT">|</td>
<td align="LEFT">``|"&nbsp;<i>R</i>&nbsp;<i>R'</i></td>
</tr>
<tr valign="MIDDLE"><td align="LEFT">&nbsp;</td>
<td align="RIGHT">|</td>
<td align="LEFT">*&nbsp;<i>R'</i></td>
</tr>
<tr valign="MIDDLE"><td align="LEFT">&nbsp;</td>
<td align="RIGHT">|</td>
<td align="LEFT">&nbsp;</td>
</tr>
</tbody></table>
</div><p></p>

<p>

</p><h3><a name="SECTION00042100000000000000">
3.2.1 Recursive Descent Parsing</a>
</h3>

<p>
Consider the transformed CFG G1 again:
</p><pre>E ::= T E'
E' ::= + T E'
     | - T E'
     |
T ::= F T'
T' ::= * F T'
     | / F T'
     |
F ::= num
    | id
</pre>
Here is a Java program that parses this grammar:
<pre>static void E () { T(); Eprime(); }
static void Eprime () {
  if (current_token == PLUS)
     { read_next_token(); T(); Eprime(); }
  else if (current_token == MINUS)
     { read_next_token(); T(); Eprime(); };
}
static void T () { F(); Tprime(); }
static void Tprime() {
  if (current_token == TIMES)
     { read_next_token(); F(); Tprime(); }
  else if (current_token == DIV)
     { read_next_token(); F(); Tprime(); };
}
static void F () {
  if (current_token == NUM || current_token == ID)
     read_next_token();
  else error();
}
</pre>
In general, for each nonterminal we write one procedure; For each
nonterminal in the rhs of a rule, we call the nonterminal's procedure;
For each terminal, we compare the current token with the expected
terminal.  If there are multiple productions for a nonterminal, we use
an if-then-else statement to choose which rule to apply.
If there was a left recursion in a production, we would have had an infinite recursion.

<p>
Please look at the following web page for a demo of the recursive descent algorithm using Java aplets:
<a name="tex2html7" href="http://www.upb.de/cs/ag-kastens/uebi/parsdemo/">http://www.upb.de/cs/ag-kastens/uebi/parsdemo/</a>
</p><p>

</p><h3><a name="SECTION00042200000000000000">
3.2.2 Predictive Parsing Using Tables</a>
</h3>

<p>
Predictive parsing can also be accomplished using a <em>predictive
parsing table</em> and a stack. It is sometimes called non-recursive
predictive parsing.  The idea is that we construct a table
<!-- MATH
 $M[X,token]$
 -->
<i>M</i>[<i>X</i>, <i>token</i>] which indicates which production to use if the top of the
stack is a nonterminal <i>X</i> and the current token is equal to <i>token</i>;
in that case we pop <i>X</i> from the stack and we push all the rhs symbols
of the production <!-- MATH
 $M[X,token]$
 -->
<i>M</i>[<i>X</i>, <i>token</i>] in reverse order.  
We use a special symbol <code>$</code> to denote the end of file.
Let <i>S</i> be the start symbol.
Here is the parsing algorithm:
</p><pre>push(S);
read_next_token();
repeat
  X = pop();
  if (X is a terminal or '$')
     if (X == current_token)
        read_next_token();
     else error();
  else if (M[X,current_token] == "X ::= Y1 Y2 ... Yk")
     {  push(Yk);
        ...
        push(Y1);
     }
  else error();
until X == '$';
</pre>

<p>
Now the question is how to construct the parsing table.  We need first
to derive the <i>FIRST</i>[<i>a</i>] for some symbol sequence <i>a</i> and the
<i>FOLLOW</i>[<i>X</i>] for some nonterminal <i>X</i>.  In few words, <i>FIRST</i>[<i>a</i>] is the
set of terminals <i>t</i> that result after a number of derivations on
<i>a</i> (ie, <!-- MATH
 $a => ... => tb$
 -->
<i>a</i> = &gt; ... = &gt; <i>tb</i> for some <i>b</i>). For example,
<!-- MATH
 $FIRST[3+E]=\{3\}$
 -->
<i>FIRST</i>[3 + <i>E</i>] = {3} since 3 is the first terminal. To find
<!-- MATH
 $FIRST[E+T]$
 -->
<i>FIRST</i>[<i>E</i> + <i>T</i>], we need to apply one or more derivations to <i>E</i> until we
get a terminal at the beginning.  If <i>E</i> can be reduced to the empty
sequence, then the <!-- MATH
 $FIRST[E+T]$
 -->
<i>FIRST</i>[<i>E</i> + <i>T</i>] must also contain the <!-- MATH
 $FIRST[+T]=\{+\}$
 -->
<i>FIRST</i>[+ <i>T</i>] = { + }.
The <i>FOLLOW</i>[<i>X</i>] is the set of all terminals that follow <i>X</i> in any
legal derivation.  To find the <i>FOLLOW</i>[<i>X</i>], we need find all
productions <!-- MATH
 $Z ::= a X b$
 -->
<i>Z</i> : : = <i>aXb</i> in which <i>X</i> appears at the rhs.  Then the
<i>FIRST</i>[<i>b</i>] must be part of the <i>FOLLOW</i>[<i>X</i>].  If <i>b</i> is empty, then the
<i>FOLLOW</i>[<i>Z</i>] must be part of the <i>FOLLOW</i>[<i>X</i>].

</p><p>
Consider our CFG G1:
</p><pre>1)   E ::= T E' $
2)   E' ::= + T E'
3)        | - T E'
4)        |
5)   T ::= F T'
6)   T' ::= * F T'
7)        | / F T'
8)        |
9)   F ::= num
10)      | id
</pre>
<code>FIRST[F]</code> is of course <code>{num,id}</code>.  This means that
<code>FIRST[T]=FIRST[F]={num,id}</code>.  In addition,
<code>FIRST[E]=FIRST[T]={num,id}</code>.  Similarly, <code>FIRST[T']</code> is
<code>{*,/}</code> and <code>FIRST[E']</code> is <code>{+,-}</code>.

<p>
The FOLLOW of <code>E</code> is <code>{$}</code> since there is no production that
has <code>E</code> at the rhs. For <code>E'</code>, rules 1, 2, and 3 have
<code>E'</code> at the rhs. This means that the <code>FOLLOW[E']</code> must
contain both the <code>FOLLOW[E]</code> and the <code>FOLLOW[E']</code>.  The first one is
<code>{$}</code> while the latter is ignored since we are trying to find
<code>E'</code>. Similarly, to find <code>FOLLOW[T]</code>, we find the rules that
have <code>T</code> at the rhs: rules 1, 2, and 3. Then <code>FOLLOW[T]</code>
must include <code>FIRST[E']</code> and, since <i>E'</i> can be reduced to the empty sequence,
it must include <code>FOLLOW[E']</code> too (ie, <code>{$}</code>).  That is,
<code>FOLLOW[T]={+,-,$}</code>. Similarly,
<code>FOLLOW[T']=FOLLOW[T]={+,-,$}</code> from rule 5. The <code>FOLLOW[F]</code>
is equal to <code>FIRST[T']={*,/}</code> plus <code>FOLLOW[T']</code> and plus
<code>FOLLOW[T]</code> from rules 5, 6, and 7, since <code>T'</code> can be
reduced to the empty sequence.

</p><p>
To summarize, we have:

</p><p>
<table border="1" cellpadding="3">
<tbody><tr><td align="CENTER">&nbsp;</td>
<td align="CENTER">FIRST</td>
<td align="CENTER">FOLLOW</td>
</tr>
<tr><td align="CENTER">E</td>
<td align="CENTER">{num,id}</td>
<td align="CENTER">{<code>$</code>}</td>
</tr>
<tr><td align="CENTER">E'</td>
<td align="CENTER">{+,-}</td>
<td align="CENTER">{<code>$</code>}</td>
</tr>
<tr><td align="CENTER">T</td>
<td align="CENTER">{num,id}</td>
<td align="CENTER">{+,-,<code>$</code>}</td>
</tr>
<tr><td align="CENTER">T'</td>
<td align="CENTER">{*,/}</td>
<td align="CENTER">{+,-,<code>$</code>}</td>
</tr>
<tr><td align="CENTER">F</td>
<td align="CENTER">{num,id}</td>
<td align="CENTER">{+,-,*,/,<code>$</code>}</td>
</tr>
</tbody></table>

</p><p>
Now, given the above table, we can easily construct the parsing table.
For each <!-- MATH
 $t\in FIRST[a]$
 -->
<i>t</i> <img src="compiler_files/img3.png" alt="$ \in$" align="MIDDLE" border="0" height="24" width="13"> <i>FIRST</i>[<i>a</i>], add <i>X</i> : : = <i>a</i> to <i>M</i>[<i>X</i>, <i>t</i>].
If <i>a</i> can be reduced to the empty sequence, then for each 
<!-- MATH
 $t\in FOLLOW[X]$
 -->
<i>t</i> <img src="compiler_files/img3.png" alt="$ \in$" align="MIDDLE" border="0" height="24" width="13"> <i>FOLLOW</i>[<i>X</i>], add <i>X</i> : : = <i>a</i> to <i>M</i>[<i>X</i>, <i>t</i>].

</p><p>
For example, the parsing table of the grammar G1 is:

</p><p>
<table border="1" cellpadding="3">
<tbody><tr><td align="CENTER">&nbsp;</td>
<td align="CENTER">num</td>
<td align="CENTER">id</td>
<td align="CENTER">+</td>
<td align="CENTER">-</td>
<td align="CENTER">*</td>
<td align="CENTER">/</td>
<td align="CENTER"><code>$</code></td>
</tr>
<tr><td align="CENTER">E</td>
<td align="CENTER">1</td>
<td align="CENTER">1</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
</tr>
<tr><td align="CENTER">E'</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">2</td>
<td align="CENTER">3</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">4</td>
</tr>
<tr><td align="CENTER">T</td>
<td align="CENTER">5</td>
<td align="CENTER">5</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
</tr>
<tr><td align="CENTER">T'</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">8</td>
<td align="CENTER">8</td>
<td align="CENTER">6</td>
<td align="CENTER">7</td>
<td align="CENTER">8</td>
</tr>
<tr><td align="CENTER">F</td>
<td align="CENTER">9</td>
<td align="CENTER">10</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
</tr>
</tbody></table>

</p><p>
where the numbers are production numbers. For example, consider the
eighth production <i>T'</i> : : = &nbsp;. Since <code>FOLLOW[T']={+,-,$}</code>,
we add 8 to <code>M[T',+], M[T',-], M[T',$]</code>.

</p><p>
A grammar is called LL(1) if each element of the parsing table of the
grammar has at most one production element.  (The first L in LL(1)
means that we read the input from left to right, the second L means
that it uses left-most derivations only, and the number 1 means that
we need to look one token only ahead from the input.)  Thus G1 is
LL(1).  If we have multiple entries in <i>M</i>, the grammar is not LL(1).

</p><p>
We will parse now the string <code>x-2*y$</code> using the above parse table:

</p><p>
</p><pre>Stack         current_token     Rule
---------------------------------------------------------------
E                 x           M[E,id] = 1   (using E ::= T E' $)
$ E' T            x           M[T,id] = 5   (using T ::= F T')
$ E' T' F         x           M[F,id] = 10  (using F ::= id)
$ E' T' id        x           read_next_token
$ E' T'           -           M[T',-] = 8   (using T' ::= )
$ E'              -           M[E',-] = 3   (using E' ::= - T E')
$ E' T -          -           read_next_token
$ E' T            2           M[T,num] = 5  (using T ::= F T')
$ E' T' F         2           M[F,num] = 9  (using F ::= num)
$ E' T' num       2           read_next_token
$ E' T'           *           M[T',*] = 6   (using T' ::= * F T')
$ E' T' F *       *           read_next_token
$ E' T' F         y           M[F,id] = 10  (using F ::= id)
$ E' T' id        y           read_next_token
$ E' T'           $           M[T',$] = 8   (using T' ::= )
$ E'              $           M[E',$] = 4   (using E' ::= )
$                 $           stop (accept)
</pre>

<p>
As another example, consider the following grammar:

</p><p>
</p><pre>G ::= S $
S ::= ( L )
    | a
L ::= L , S
    | S
</pre>

<p>
After left recursion elimination, it becomes

</p><p>
</p><pre>0)  G := S $
1)  S ::= ( L )
2)  S ::= a
3)  L ::= S L'
4)  L' ::= , S L'
5)  L' ::=
</pre>

<p>
The first/follow tables are:

</p><p>
<table border="1" cellpadding="3">
<tbody><tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">FIRST</td>
<td align="LEFT">FOLLOW</td>
</tr>
<tr><td align="LEFT">G</td>
<td align="LEFT">( a</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="LEFT">S</td>
<td align="LEFT">( a</td>
<td align="LEFT">, ) $</td>
</tr>
<tr><td align="LEFT">L</td>
<td align="LEFT">( a</td>
<td align="LEFT">)</td>
</tr>
<tr><td align="LEFT">L'</td>
<td align="LEFT">,</td>
<td align="LEFT">)</td>
</tr>
</tbody></table>

</p><p>
which are used to create the parsing table:

</p><p>
<table border="1" cellpadding="3">
<tbody><tr><td align="LEFT">&nbsp;</td>
<td align="CENTER">(</td>
<td align="CENTER">)</td>
<td align="CENTER">a</td>
<td align="CENTER">,</td>
<td align="CENTER">$</td>
</tr>
<tr><td align="LEFT">G</td>
<td align="CENTER">0</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">0</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
</tr>
<tr><td align="LEFT">S</td>
<td align="CENTER">1</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">2</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
</tr>
<tr><td align="LEFT">L</td>
<td align="CENTER">3</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">3</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
</tr>
<tr><td align="LEFT">L'</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">5</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">4</td>
<td align="CENTER">&nbsp;</td>
</tr>
</tbody></table>

</p><p>

</p><h2><a name="SECTION00043000000000000000">
3.3 Bottom-up Parsing</a>
</h2>

<p>
The basic idea of a bottom-up parser is that we use grammar
productions in the opposite way (from right to left). Like for predictive
parsing with tables, here too we use a stack to push symbols. If the
first few symbols at the top of the stack match the rhs of some rule,
then we pop out these symbols from the stack and we push the lhs (left-hand-side) of
the rule. This is called a <em>reduction</em>. For example, if the stack
is <code>x * E + E</code> (where <code>x</code> is the bottom of stack) and there
is a rule <code>E ::= E + E</code>, then we pop out <code>E + E</code> from the
stack and we push <code>E</code>; ie,  the stack becomes <code>x * E</code>. The
sequence <code>E + E</code> in the stack is called a <em>handle</em>. But
suppose that there is another rule <code>S ::= E</code>, then <code>E</code>
is also a handle in the stack.  Which one to choose? Also what happens
if there is no handle?  The latter question is easy to answer: we push
one more terminal in the stack from the input stream and check again
for a handle.  This is called <em>shifting</em>. So another name for
bottom-up parsers is shift-reduce parsers. There two actions only:

</p><ol>
<li>shift the current input token in the stack and read the next token, and
</li>
<li>reduce by some production rule.
</li>
</ol>
Consequently the problem is to recognize when to shift and when to
reduce each time, and, if we reduce, by which rule. Thus we need a
recognizer for handles so that by scanning the stack we can decide the
proper action. The recognizer is actually a finite state machine
exactly the same we used for REs. But here the language symbols
include both terminals and nonterminal (so state transitions can be
for any symbol) and the final states indicate either reduction by some rule or
a final acceptance (success).

<p>
A DFA though can only be used if we always have one choice for each
symbol.  But this is not the case here, as it was apparent from the
previous example: there is an ambiguity in recognizing handles in the
stack. In the previous example, the handle can either be <code>E + E</code>
or <code>E</code>. This ambiguity will hopefully be resolved later when we
read more tokens. This implies that we have multiple choices and each
choice denotes a valid potential for reduction. So instead of a DFA we
must use a NFA, which in turn can be mapped into a DFA as we learned
in Section&nbsp;<a href="#convert">2.3</a>. These two steps (extracting the NFA and map
it to DFA) are done in one step using <em>item sets</em> (described below).

</p><p>

</p><h3><a name="SECTION00043100000000000000">
3.3.1 Bottom-up Parsing</a>
</h3>

<p>
Recall the original CFG G1:
</p><pre>0)  S :: = E $
1)  E ::= E + T
2)      | E - T
3)      | T
4)  T ::= T * F
5)      | T / F
6)      | F
7)  F ::= num
8)      | id
</pre>
Here is a trace of the bottom-up parsing of the input <code>x-2*y$</code>:
<pre>      Stack          rest-of-the-input          Action
---------------------------------------------------------------
 1)                    id - num * id $      shift
 2)   id               - num * id $         reduce by rule 8
 3)   F                - num * id $         reduce by rule 6
 4)   T                - num * id $         reduce by rule 3
 5)   E                - num * id $         shift
 6)   E -              num * id $           shift
 7)   E - num          * id $               reduce by rule 7
 8)   E - F            * id $               reduce by rule 6
 9)   E - T            * id $               shift
10)   E - T *          id $                 shift
11)   E - T * id       $                    reduce by rule 8
12)   E - T * F        $                    reduce by rule 4
13)   E - T            $                    reduce by rule 2
14)   E $                                   shift
15)   S                                     accept (reduce by rule 0)
</pre>
We start with an empty stack and we finish when the stack contains the non-terminal <code>S</code> only.
Every time we shift, we push the current token into the stack and read the
next token from the input sequence. When we reduce by a rule,
the top symbols of the stack (the handle) must match the rhs of the rule <em>exactly</em>.
Then we replace these top symbols with the lhs of the rule (a non-terminal).
For example, in the line 12 above, we reduce by rule 4 (<code>T ::= T * F</code>).
Thus we pop the symbols <code>F</code>, <code>*</code>, and <code>T</code> (in that order)
and we push <code>T</code>.
At each instance, the stack (from bottom to top)
concatenated with the rest of the input (the unread input) forms a valid
bottom-up derivation from the input sequence. That is, the derivation sequence here is:
<pre> 1)       id - num * id $
 3)  =&gt;   F - num * id $
 4)  =&gt;   T - num * id $
 5)  =&gt;   E - num * id $
 8)  =&gt;   E - F * id $
 9)  =&gt;   E - T * id $
12)  =&gt;   E - T * F $
13)  =&gt;   E - T $
14)  =&gt;   E $
15)  =&gt;   S
</pre>
The purpose of the above example is to understand how bottom-up parsing works.
It involves lots of guessing.  We will see that we don't actually push
symbols in the stack.  Rather, we push states that represent possibly
more than one potentials for rule reductions.

<p>
As we learned in earlier sections, a DFA can be represented by
transition tables.  In this case we use two tables: ACTION and GOTO.
ACTION is used for recognizing which action to perform and, if it is
shifting, which state to go next. GOTO indicates which state to go
after a reduction by a rule for a nonterminal symbol. We will first
learn how to use the tables for parsing and then how to construct
these tables.

</p><p>

</p><h3><a name="SECTION00043200000000000000">
3.3.2 Shift-Reduce Parsing Using the ACTION/GOTO Tables</a>
</h3>

<p>
Consider the following grammar:

</p><p>
</p><pre>0) S ::= R $
1) R ::= R b
2) R ::= a
</pre>
which parses the R.E. <i>ab</i><sup>*</sup>$.

<p>
The DFA that recognizes the handles for this grammar is:
(it will be explained later how it is constructed)

</p><p>
<img src="compiler_files/lr3.gif" alt="lr3.gif" align="BOTTOM" border="0" height="146" width="268">

</p><p>
where 'r2' for example means reduce by rule 2 (ie, by <code>R :: = a</code>)
and 'a' means accept. The transition from 0 to 3 is done when the
current state is 0 and the current input token is 'a'. If we are in
state 0 and have completed a reduction by some rule for R (either rule
1 or 2), then we jump to state 1.

</p><p>
The ACTION and GOTO tables that correspond to this DFA are:

</p><p>
<table border="1" cellpadding="3">
<tbody><tr><td align="CENTER">state</td>
<td colspan="3" align="CENTER">action</td>
<td colspan="2" align="CENTER">goto</td>
</tr>
<tr><td align="CENTER">&nbsp;</td>
<td align="CENTER">a</td>
<td align="CENTER">b</td>
<td align="CENTER"><code>$</code></td>
<td align="CENTER">S</td>
<td align="CENTER">R</td>
</tr>
<tr><td align="CENTER">0</td>
<td align="CENTER">s3</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">1</td>
</tr>
<tr><td align="CENTER">1</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">s4</td>
<td align="CENTER">s2</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
</tr>
<tr><td align="CENTER">2</td>
<td align="CENTER">a</td>
<td align="CENTER">a</td>
<td align="CENTER">a</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
</tr>
<tr><td align="CENTER">3</td>
<td align="CENTER">r2</td>
<td align="CENTER">r2</td>
<td align="CENTER">r2</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
</tr>
<tr><td align="CENTER">4</td>
<td align="CENTER">r3</td>
<td align="CENTER">r3</td>
<td align="CENTER">r3</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
</tr>
</tbody></table>

</p><p>
where for example s3 means shift a token into the stack and go to state 3.
That is, transitions over terminals become shifts in the ACTION table
while transitions over non-terminals are used in the GOTO table.

</p><p>
Here is the shift-reduce parser:
</p><pre>push(0);
read_next_token();
for(;;)
{  s = top();    /* current state is taken from top of stack */
   if (ACTION[s,current_token] == 'si')   /* shift and go to state i */
   {  push(i);
      read_next_token();
   }
   else if (ACTION[s,current_token] == 'ri')
   /* reduce by rule i: X ::= A1...An */
   {  perform pop() n times;
      s = top();    /* restore state before reduction from top of stack */
      push(GOTO[s,X]);   /* state after reduction */
   }
   else if (ACTION[s,current_token] == 'a')
      success!!
   else error();
}
</pre>
Note that the stack contains state numbers only, not symbols.

<p>
For example, for the input <code>abb$</code>, we have:

</p><p>
</p><pre>Stack     rest-of-input   Action
----------------------------------------------------------------------------
0         abb$            s3
0 3       bb$             r2  (pop(), push GOTO[0,R] since R ::= a)
0 1       bb$             s4
0 1 4     b$              r1  (pop(), pop(), push GOTO[0,R] since R ::= R b)
0 1       b$              s4
0 1 4     $               r1  (pop(), pop(), push GOTO[0,R] since R ::= R b)
0 1       $               s2
0 1 2                     accept
</pre>

<p>

</p><h3><a name="SECTION00043300000000000000">
3.3.3 Table Construction</a>
</h3>

<p>
Now the only thing that remains to do is, given a CFG, to construct
the finite automaton (DFA) that recognizes handles. After that,
constructing the ACTION and GOTO tables will be straightforward.

</p><p>
The states of the finite state machine correspond to item sets.  An
<em>item</em> (or <em>configuration</em>) is a production with a dot (.) at
the rhs that indicates how far we have progressed using this rule to
parse the input.  For example, the item <code>E ::= E + . E</code> indicates
that we are using the rule <code>E ::= E + E</code> and that, using this
rule, we have parsed <code>E</code>, we have seen a token <code>+</code>, and we
are ready to parse another <code>E</code>. Now, why do we need a set (an item
set) for each state in the state machine? Because many production
rules may be applicable at this point; later when we will scan more
input tokens we will be able tell exactly which production to use.
This is the time when we are ready to reduce by the chosen production.

</p><p>
For example, say that we are in a state that corresponds to the item set
with the following items:
</p><pre>S ::= id . := E
S ::= id . : S
</pre>
This state indicates that we have already parsed an <code>id</code> from the input
but we have 2 possibilities: if the next token is <code>:=</code> we will use
the first rule and if it is <code>:</code> we will use the second.

<p>
Now we are ready to construct our automaton. Since we do not want to
work with NFAs, we build a DFA directly.  So it is important to
consider closures (like we did when we transformed NFAs to DFAs).  The
closure of an item <code>X ::= a . t b</code> (ie, the dot appears before a
terminal <code>t</code>) is the singleton set that contains the item <code>X ::= a . t b</code> only.
The closure of an item <code>X ::= a . Y b</code> (ie, the dot appears before a
nonterminal <code>Y</code>) is the set consisting of the item itself, plus
all productions for <code>Y</code> with the dot at the left of the rhs, plus
the closures of these items. For example, the closure of the item
<code>E ::= E + . T</code> is the set:
</p><pre>E ::= E + . T
T ::= . T * F
T ::= . T / F
T ::= . F
F ::= . num
F ::= . id
</pre>

<p>
The initial state of the DFA (state 0) is the closure of the item
<code>S ::= . a $</code>, where <code> S ::= a $</code> is the first rule.  In simple words,
if there is an item <code>X ::= a . s b</code> in an item set, where
<code>s</code> is a symbol (terminal or nonterminal), we have a transition
labelled by <code>s</code> to an item set that contains
<code>X ::= a s . b</code>. But it's a little bit more complex than that:

</p><ol>
<li>If we have more than one item with a dot before the same symbol
<code>s</code>, say <code>X ::= a . s b</code> and <code>Y ::= c . s d</code>, then the
new item set contains both <code>X ::= a s . b</code> and
<code>Y ::= c s . d</code>. 
</li>
<li>We need to get the closure of the new item set.
</li>
<li>We have to check if this item set has been appeared
before so that we don't create it again. 
</li>
</ol>

<p>
For example, our previous grammar which parses the R.E. <i>ab</i><sup>*</sup>$:

</p><p>
</p><pre>0) S ::= R $
1) R ::= R b
2) R ::= a
</pre>
has the following item sets:

<p>
<img src="compiler_files/lr4.gif" alt="lr4.gif" align="BOTTOM" border="0" height="229" width="578">

</p><p>
which forms the following DFA:

</p><p>
<img src="compiler_files/lr3.gif" alt="lr3.gif" align="BOTTOM" border="0" height="146" width="268">

</p><p>
We can understand now the R transition: If we read an entire R term (that is, after we reduce by a rule that parses R),
and the previous state before the reduction was 0, we jump to state 1.

</p><p>
As another example, the CFG:

</p><p>
</p><pre>1)  S ::= E $
2)  E ::= E + T
3)      | T
4)  T ::= id
5)     | ( E )
</pre>
has the following item sets:

<p>
</p><pre>I0:  S ::= . E $                  I4:  E ::= E + T .
     E ::= . E + T
     E ::= . T                    I5:  T ::= id .
     T ::= . id
     T ::= . ( E )                I6:  T ::= ( . E )
                                       E ::= . E + T
I1:  S ::= E . $                       E ::= . T
     E ::= E . + T                     T ::= . id
                                       T ::= . ( E )
I2:  S ::= E $ .
                                  I7:  T ::= ( E . )
I3:  E ::= E + . T                     E ::= E . + T
     T ::= . id
     T ::= . ( E )                I8:  T ::= ( E ) .

                                  I9:  E ::= T .
</pre>
that correspond to the DFA:

<p>
<img src="compiler_files/lr1.gif" alt="lr1.gif" align="BOTTOM" border="0" height="296" width="252">

</p><p>
Explanation: The initial state <code>I0</code> is the closure of
<code>S ::= . E $</code>.  The two items <code>S ::= . E $</code> and
<code>E ::= . E + T</code> in <code>I0</code> must have a transition by
<code>E</code> since the dot appears before <code>E</code>.  So we have a new item
set <code>I1</code> and a transition from <code>I0</code> to <code>I1</code> by
<code>E</code>. The <code>I1</code> item set must contain the closure of the items
<code>S ::= . E $</code> and <code>E ::= . E + T</code> with the dot moved one
place right. Since the dot in <code>I1</code> appears before terminals
(<code>$</code> and <code>+</code>), the closure is the items themselves.
Similarly, we have a transition from <code>I0</code> to <code>I9</code> by
<code>T</code>, to <code>I5</code> by <code>id</code>, to <code>I6</code> by '<code>(</code>', etc,
and we do the same thing for all item sets.

</p><p>
Now if we have an item set with only one item <code>S ::= E .</code>, where
<code>S</code> is the start symbol, then this state is the <em>accepting state</em>
(state <code>I2</code> in the example).  If we have an item set with only
one item <code>X ::= a .</code> (where the dot appears at the end of the rhs),
then this state corresponds to a reduction by the production
<code>X ::= a</code>. If we have a transition by a terminal symbol (such as
from <code>I0</code> to <code>I5</code> by <code>id</code>), then this corresponds to a
shifting. 

</p><p>
The ACTION and GOTO tables that correspond to this DFA are:

</p><p>
<table border="1" cellpadding="3">
<tbody><tr><td align="CENTER">state</td>
<td colspan="5" align="CENTER">action</td>
<td colspan="3" align="CENTER">goto</td>
</tr>
<tr><td align="CENTER">&nbsp;</td>
<td align="CENTER">id</td>
<td align="CENTER">(</td>
<td align="CENTER">)</td>
<td align="CENTER">+</td>
<td align="CENTER"><code>$</code></td>
<td align="CENTER">S</td>
<td align="CENTER">E</td>
<td align="CENTER">T</td>
</tr>
<tr><td align="CENTER">0</td>
<td align="CENTER">s5</td>
<td align="CENTER">s6</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">1</td>
<td align="CENTER">9</td>
</tr>
<tr><td align="CENTER">1</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">s3</td>
<td align="CENTER">s2</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
</tr>
<tr><td align="CENTER">2</td>
<td align="CENTER">a</td>
<td align="CENTER">a</td>
<td align="CENTER">a</td>
<td align="CENTER">a</td>
<td align="CENTER">a</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
</tr>
<tr><td align="CENTER">3</td>
<td align="CENTER">s5</td>
<td align="CENTER">s6</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">4</td>
</tr>
<tr><td align="CENTER">4</td>
<td align="CENTER">r2</td>
<td align="CENTER">r2</td>
<td align="CENTER">r2</td>
<td align="CENTER">r2</td>
<td align="CENTER">r2</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
</tr>
<tr><td align="CENTER">5</td>
<td align="CENTER">r4</td>
<td align="CENTER">r4</td>
<td align="CENTER">r4</td>
<td align="CENTER">r4</td>
<td align="CENTER">r4</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
</tr>
<tr><td align="CENTER">6</td>
<td align="CENTER">s5</td>
<td align="CENTER">s6</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">7</td>
<td align="CENTER">9</td>
</tr>
<tr><td align="CENTER">7</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">s8</td>
<td align="CENTER">s3</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
</tr>
<tr><td align="CENTER">8</td>
<td align="CENTER">r5</td>
<td align="CENTER">r5</td>
<td align="CENTER">r5</td>
<td align="CENTER">r5</td>
<td align="CENTER">r5</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
</tr>
<tr><td align="CENTER">9</td>
<td align="CENTER">r3</td>
<td align="CENTER">r3</td>
<td align="CENTER">r3</td>
<td align="CENTER">r3</td>
<td align="CENTER">r3</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
</tr>
</tbody></table>

</p><p>
As another example, consider the following augmented grammar:

</p><p>
</p><pre>0) S' ::= S $
1) S  ::= B B
2) B  ::= a B
3) B  ::= c
</pre>

<p>
The state diagram is:

</p><p>
<img src="compiler_files/exam13.gif" alt="exam13.gif" align="BOTTOM" border="0" height="365" width="488">

</p><p>
The ACTION and GOTO parsing tables are:

</p><p>
<table border="1" cellpadding="3">
<tbody><tr><td align="LEFT">state</td>
<td colspan="3" align="CENTER">action</td>
<td colspan="3" align="CENTER">goto</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="CENTER">a</td>
<td align="CENTER">c</td>
<td align="CENTER">$</td>
<td align="CENTER">S'</td>
<td align="CENTER">S</td>
<td align="CENTER">B</td>
</tr>
<tr><td align="LEFT">0</td>
<td align="CENTER">s5</td>
<td align="CENTER">s7</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">1</td>
<td align="CENTER">3</td>
</tr>
<tr><td align="LEFT">1</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">s2</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
</tr>
<tr><td align="LEFT">2</td>
<td align="CENTER">a</td>
<td align="CENTER">a</td>
<td align="CENTER">a</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
</tr>
<tr><td align="LEFT">3</td>
<td align="CENTER">s5</td>
<td align="CENTER">s7</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">4</td>
</tr>
<tr><td align="LEFT">4</td>
<td align="CENTER">r1</td>
<td align="CENTER">r1</td>
<td align="CENTER">r1</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
</tr>
<tr><td align="LEFT">5</td>
<td align="CENTER">s5</td>
<td align="CENTER">s7</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">6</td>
</tr>
<tr><td align="LEFT">6</td>
<td align="CENTER">r2</td>
<td align="CENTER">r2</td>
<td align="CENTER">r2</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
</tr>
<tr><td align="LEFT">7</td>
<td align="CENTER">r3</td>
<td align="CENTER">r3</td>
<td align="CENTER">r3</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
</tr>
</tbody></table>

</p><p>
As yet another example, the grammar:
</p><pre>S ::= E $
E ::= ( L )
E ::= ( )
E ::= id
L ::= L , E
L ::= E
</pre>
has the following state diagram:

<p>
<img src="compiler_files/lr0.gif" alt="lr0.gif" align="BOTTOM" border="0" height="279" width="548">

</p><p>
If we have an item set with more than one items with a dot at the end
of their rhs, then this is an error, called a <em>reduce-reduce
conflict</em>, since we can not choose which rule to use to reduce. This
is a very important error and it should never happen. Another conflict
is a <em>shift-reduce conflict</em> where we have one reduction and one or
more shifts at the same item set. For example, when we find <code>b</code>
in <code>a+b+c</code>, do we reduce <code>a+b</code> or do we shift the plus token
and reduce <code>b+c</code> later? This type of ambiguities is usually
resolved by assigning the proper precedences to operators (described
later). The shift-reduce conflict is not as severe as the reduce-reduce
conflict: a parser generator selects reduction against shifting but we may
get a wrong behavior. If the grammar has no reduce-reduce and no
shift-reduce conflicts, it is LR(0) (ie. we read left-to-right, we use right-most
derivations, and we don't look ahead any tokens).

</p><p>

</p><h3><a name="SECTION00043400000000000000">
3.3.4 SLR(1), LR(1), and LALR(1) Grammars</a>
</h3>

<p>
Here is an example of a grammar that is not LR(0):

</p><p>
</p><pre>1)  S ::= E $
2)  E ::= E + T
3)      | T
4)  T ::= T * F
5)      | F
6)  F ::= id
7)     | ( E )
</pre>

<p>
Let's focus on two item sets only:

</p><p>
</p><pre>I0:  S ::= . E $                  I1:  E ::= T .
     E ::= . E + T                     T ::= T . * F
     E ::= . T                    
     T ::= . T * F
     T ::= . F
     F ::= . id
     F ::= . ( E )
</pre>

<p>
State <code>I1</code> has a shift-reduce conflict.
Another example is:

</p><p>
</p><pre>S ::= X
X ::= Y
    | id
Y ::= id
</pre>
which includes the following two item sets:

<p>
</p><pre>I0:  S ::= . X $
     X ::= . Y             I1:  X ::= id .
     X ::= . id                 Y ::= id .
     Y ::= . id
</pre>

<p>
State <code>I1</code> has a reduce-reduce conflict.

</p><p>
Can we find an easy fix for the reduce-reduce and the shift-reduce
conflicts?  Consider the state <code>I1</code> of the first example
above. The FOLLOW of <code>E</code> is <code>{$,+,)}</code>. We can see that
<code>*</code> is not in the <code>FOLLOW[E]</code>, which means that if we could
see the next token (called the <em>lookahead token</em>) and this token
is <code>*</code>, then we can use the item <code>T ::= T . * F</code> to do a
shift; otherwise, if the lookahead is one of <code>{$,+,)}</code>, we reduce
by <code>E ::= T</code>.  The same trick can be used in the case of a
reduce-reduce conflict.  For example, if we have a state with the
items <code>A ::= a .</code> and <code>B ::= b .</code>, then if <code>FOLLOW[A]</code>
doesn't overlap with <code>FOLLOW[B]</code>, then we can deduce which
production to reduce by inspecting the lookahead token.  This grammar
(where we can look one token ahead) is called SLR(1) and is more
powerful than LR(0).

</p><p>
The previous trick is not always possible. Consider the grammar:

</p><p>
</p><pre>S ::= E $
E ::= L = R
    | R
L ::= * R
    | id
R ::= L
</pre>
for C-style variable assignments. Consider the two states:

<p>
</p><pre>I0:  S ::= . E $
     E ::= . L = R             I1:  E ::= L . = R
     E ::= . R                      R ::= L .
     L ::= . * R
     L ::= . id
     R ::= . L
</pre>
we have a shift-reduce conflict in <code>I1</code>.  The FOLLOW of <code>R</code>
is the union of the FOLLOW of <code>E</code> and the FOLLOW of <code>L</code>, ie, it is
<code>{$,=}</code>. In this case, <code>=</code> is a member of the FOLLOW of
<code>R</code>, so we can't decide shift or reduce using just one lookahead.

<p>
An even more powerful grammar is LR(1), described below. This grammar
is not used in practice because of the large number of states it
generates.  A simplified version of this grammar, called LALR(1), has
the same number of states as LR(0) but it is far more powerful than
LR(0) (but less powerful than LR(1)). It is the most important grammar
from all grammars we learned so far. CUP, Bison, and Yacc recognize LALR(1)
grammars.

</p><p>
Both LR(1) and LALR(1) check one lookahead token (they read one token
ahead from the input stream - in addition to the current token).  An
item used in LR(1) and LALR(1) is like an LR(0) item but with the
addition of a set of expected lookaheads which indicate what lookahead
tokens would make us perform a reduction when we are ready to reduce
using this production rule. The expected lookahead symbols for a rule
<code>X ::= a</code> are always a subset or equal to <code>FOLLOW[X]</code>.  The
idea is that an item in an itemset represents a potential for a
reduction using the rule associated with the item. But each itemset
(ie. state) can be reached after a number of transitions in the state
diagram, which means that each itemset has an implicit context, which,
in turn, implies that there are only few terminals permitted to appear
in the input stream after reducing by this rule.  In SLR(1), we made
the assumption that the followup tokens after the reduction by
<code>X ::= a</code> are exactly equal to <code>FOLLOW[X]</code>. But this is too
conservative and may not help us resolve the conflicts. So the idea is
to restrict this set of followup tokens by making a more careful
analysis by taking into account the context in which the item
appears. This will reduce the possibility of overlappings in
sift/reduce or reduce/reduce conflict states. For example,
</p><pre>L ::= * . R, =$
</pre>
indicates that we have the item
<code>L ::= * . R</code> and that we have parsed <code>*</code> and will reduce by <code>L ::= * R</code> only
when we parse <code>R</code> and the next lookahead token
is either <code>=</code> or <code>$</code> (end of file). It is very important to
note that the FOLLOW of <code>L</code> (equal to <code>{$,=}</code>) is always a
superset or equal to the expected lookaheads. The point of propagating
expected lookaheads to the items is that we want to restrict the FOLLOW
symbols so that only the relevant FOLLOW symbols would affect our
decision when to shift or reduce in the case of a shift-reduce or
reduce-reduce conflict. For example, if we have a state with two items
<code>A ::= a ., s1</code> and <code>B ::= b ., s2</code>, where <code>s1</code> and
<code>s2</code> are sets of terminals, then if <code>s1</code> and <code>s2</code> are
not overlapping, this is not a reduce-reduce error any more, since we
can decide by inspecting the lookahead token.

<p>
So, when we construct the item sets, we also propagate the expected
lookaheads. When we have a transition from <code>A ::= a . s b</code> by a
symbol <code>s</code>, we just propagate the expected lookaheads.  The
tricky part is when we construct the closures of the items.  Recall
that when we have an item <code>A ::= a . B b</code>, where <code>B</code> is a
nonterminal, then we add all rules <code>B ::= . c</code> in the item
set. If <code>A ::= a . B b</code> has an expected lookahead <code>t</code>, then
<code>B ::= . c</code> has all the elements of <code>FIRST[bt]</code> as expected
lookaheads.

</p><p>
For example, consider the previous grammar:

</p><p>
</p><pre>S ::= E $
E ::= L = R
    | R
L ::= * R
    | id
R ::= L
</pre>

<p>
Two of the LR(1) item sets are:

</p><p>
</p><pre>I0:  S ::= . E $     ?
     E ::= . L = R   $          I1:  E ::= L . = R   $
     E ::= . R       $               R ::= L .       $
     L ::= . * R     =$
     L ::= . id      =$
     R ::= . L       $
</pre>

<p>
We always start with expected lookahead <code>?</code> for the rule
<code>S ::= E $</code>, which basically indicates that we don't care what is
after end-of-file.  The closure of <code>L</code> will contain both <code>=</code>
and <code>$</code> for expected lookaheads because in <code>E ::= . L = R</code>
the first symbol after <code>L</code> is <code>=</code>, and in <code>R ::= . L</code>
(the closure of <code>E ::= . R</code>) we use the <code>$</code> terminal for
expected lookahead propagated from <code>E ::= . R</code> since there is no
symbol after <code>L</code>. We can see that there is no shift reduce error
in <code>I1</code>: if the lookahead token is <code>$</code> we reduce, otherwise
we shift (for <code>=</code>).

</p><p>
In LR(1) parsing, an item <code>A ::= a, s1</code> is different from
<code>A ::= a, s2</code> if <code>s1</code> is different from <code>s2</code>. This
results to a large number of states since the combinations of expected
lookahead symbols can be very large. To reduce the number of states,
when we have two items like those two, instead of creating two states
(one for each item), we combine the two states into one by creating an
item <code>A := a, s3</code>, where <code>s3</code> is the union of <code>s1</code> and
<code>s2</code>. Since we make the expected lookahead sets larger, there is
a danger that some conflicts will have worse chances to be resolved.
But the number of states we get is the same as that for LR(0).  This
grammar is called LALR(1).

</p><p>
There is an easier way to construct the LALR(1) item sets. Simply start
by constructing the LR(0) item sets. Then we add the expected
lookaheads as follows: whenever we find a new lookahead using the
closure law given above we add it in the proper item; when we
propagate lookaheads we propagate all of them. Sometimes when we
insert a new lookahead we need to do all the lookahead propagations
again for the new lookahead even in the case we have already
constructed the new items. So we may have to loop through the items
many times until no new lookaheads are generated. Sounds hard?  Well
that's why there are parser generators to do that automatically for you.
This is how CUP work.

</p><p>

</p><h3><a name="SECTION00043500000000000000">
3.3.5 Practical Considerations for LALR(1) Grammars</a>
</h3>

<p>
Most parsers nowdays are specified using LALR(1) grammars fed to a
parser generator, such as CUP. There are few tricks that we need to
know to avoid reduce-reduce and shift-reduce conflicts.

</p><p>
When we learned about top-down predictive parsing, we were told that
left recursion is bad. For LALR(1) the opposite is true: left recursion
is good, right recursion is bad. Consider this:

</p><p>
</p><pre>L ::= id , L
    | id
</pre>
which captures a list of ids separated by commas. If the FOLLOW of <code>L</code>
(or to be more precise, the expected lookaheads for <code>L ::= id</code>) contains
the comma token, we are in big trouble. We can use instead:

<p>
</p><pre>L ::= L , id
    | id
</pre>

<p>
Left recursion uses less stack than right recursion and it also
produces left associative trees (which is what we usually want).

</p><p>
Some shift-reduce conflicts are very difficult to eliminate.
Consider the infamous if-then-else conflict:

</p><p>
</p><pre>S ::= if E then S else S
    | if E then S
    | ...
</pre>

<p>
Read Section 3.3 in the textbook to see how this can be eliminated.

</p><p>
Most shift-reduce errors though are easy to remove by assigning
precedence and associativity to operators.  Consider the grammar:

</p><p>
</p><pre>S ::= E $
E ::= E + E
    | E * E
    | ( E )
    | id
    | num
</pre>
and four of its LALR(1) states:

<p>
</p><pre>I0:  S ::= . E $    ?
     E ::= . E + E  +*$    I1:  S ::= E . $    ?      I2:  E ::= E * . E   +*$
     E ::= . E * E  +*$         E ::= E . + E  +*$         E ::= . E + E   +*$
     E ::= . ( E )  +*$         E ::= E . * E  +*$         E ::= . E * E   +*$
     E ::= . id     +*$                                    E ::= . ( E )   +*$
     E ::= . num    +*$    I3:  E ::= E * E .   +*$        E ::= . id      +*$
                                E ::= E . + E   +*$        E ::= . num     +*$
                                E ::= E . * E   +*$
</pre>

<p>
Here we have a shift-reduce error. Consider the first two items in
<code>I3</code>.  If we have <code>a*b+c</code> and we parsed <code>a*b</code>, do we
reduce using <code>E ::= E * E</code> or do we shift more symbols?  In the
former case we get a parse tree <code>(a*b)+c</code>; in the latter case we
get <code>a*(b+c)</code>. To resolve this conflict, we can specify that
<code>*</code> has higher precedence than <code>+</code>.  The precedence of a
grammar production is equal to the precedence of the rightmost token
at the rhs of the production. For example, the precedence of the
production <code>E ::= E * E</code> is equal to the precedence of the
operator <code>*</code>, the precedence of the production <code>E ::= ( E )</code>
is equal to the precedence of the token <code>)</code>, and the precedence
of the production <code>E ::= if E then E else E</code> is equal to the
precedence of the token <code>else</code>.  The idea is that if the
lookahead has higher precedence than the production currently used, we
shift.  For example, if we are parsing <code>E + E</code> using the
production rule <code>E ::= E + E</code> and the lookahead is <code>*</code>, we
shift <code>*</code>.  If the lookahead has the same precedence as that of
the current production and is left associative, we reduce, otherwise
we shift.  The above grammar is valid if we define the precedence and
associativity of all the operators.  Thus, it is very important when
you write a parser using CUP or any other LALR(1) parser generator to
specify associativities and precedences for most tokens (especially
for those used as operators). Note: you can explicitly define
the precedence of a rule in CUP using the <code>%prec</code> directive:

</p><p>
</p><pre> E ::= MINUS E   %prec UMINUS  
</pre>
where <code>UMINUS</code> is a pseudo-token that has higher precedence than
<code>TIMES</code>, <code>MINUS</code> etc, so that <code>-1*2</code> is equal to
<code>(-1)*2</code>, not to <code>-(1*2)</code>.

<p>
Another thing we can do when specifying an LALR(1) grammar for a parser
generator is error recovery. All the entries in the ACTION and GOTO
tables that have no content correspond to syntax errors.  The simplest
thing to do in case of error is to report it and stop the parsing. But
we would like to continue parsing finding more errors. This is called
<em>error recovery</em>. Consider the grammar:

</p><p>
</p><pre>S ::= L = E ;
    | { SL } ;
    | error ;
SL ::= S ;
     | SL S ;
</pre>

<p>
The special token <code>error</code> indicates to the parser what to do in
case of invalid syntax for <code>S</code> (an invalid statement). In this
case, it reads all the tokens from the input stream until it finds the
first semicolon. The way the parser handles this is to first push an
<code>error</code> state in the stack.  In case of an error, the parser pops
out elements from the stack until it finds an error state where it can
proceed. Then it discards tokens from the input until a restart is
possible.  Inserting error handling productions in the proper places
in a grammar to do good error recovery is considered very hard.

</p><p>

</p><h2><a name="SECTION00044000000000000000">
3.4 Case Study: The Calculator Parser</a>
</h2>

<p>
The file <a name="tex2html8" href="http://lambda.uta.edu/cse5317/calc/simple_calc.cup">simple_calc.cup</a>
contains
the CUP grammar for the calculator parser (without semantics actions).
Notice the section that specifies the precedence and associativity of the terminals symbols:
</p><pre>precedence nonassoc	ELSE;
precedence right	OR;
precedence right	AND;
precedence nonassoc	NOT;
precedence left		EQ, LT, GT, LE, GE, NE;
precedence left		PLUS, MINUS;
precedence left		TIMES, DIV;
</pre>
It lists the terminals in order of precedence, from lower to higher.
Thus, <code>TIMES</code> and <code>DIV</code> have the highest precedence.  For
example, <code>1+3*4</code> is equivalent to <code>1+(3*4)</code> since
<code>TIMES</code> has higher precedence than <code>PLUS</code>.  In addition, the
keywords left, right, and nonassoc indicate that the operators have
left, right, or no associativity at all, respectively.  This means
that <code>1+2+3</code> is equivalent to <code>(1+2)+3</code>, while <code>(x and y and z)</code>
is equivalent to <code>(x and (y and z))</code>.  This list is
very important for helping CUP resolve shift-reduce conflicts.  The
reason that we set <code>ELSE</code> to the lowest precendence is to resolve
the infamous if-then-else conflict: It basically means that we always
shift in case of nested if-then-elses.

<p>
Another thing to notice is that, when there is a choice, left
recursion is preferred from right recursion, such as in:
</p><pre>expl ::= expl COMMA exp
       | exp
</pre>

<p>

</p><h1><a name="SECTION00050000000000000000"></a><a name="ast-syntax"></a>
<br>
4 Abstract Syntax
</h1>

<p>
A grammar for a language specifies a recognizer for this language: if
the input satisfies the grammar rules, it is accepted, otherwise it is
rejected.  But we usually want to perform semantic actions against some
pieces of input recognized by the grammar. For example, if we are
building a compiler, we want to generate machine code. The semantic
actions are specified as pieces of code attached to production rules.
For example, the CUP productions:

</p><p>
</p><pre>E ::= E:e1 + E:e2        {: RESULT = e1 + e2; :}
    | E:e1 - E:e2        {: RESULT = e1 - e2; :}
    | num:n              {: RESULT = n; :}
    ;
</pre>
contain pieces of Java code (enclosed by <code>{: :}</code>) to be executed
at a particular point of time. Here, each expression <code>E</code> is
associated with an integer.  The goal is to calculate the value of
<code>E</code> stored in the variable <code>RESULT</code>.  For example, the first
rule indicates that we are reading one expression <code>E</code> and call
its result <code>e1</code>, then we read a <code>+</code>, then we read another
<code>E</code> and call its result <code>e2</code>, and then we are executing the
Java code <code>{: RESULT = e1 + e2; :}</code>. The code can appear at any
point of the rhs of a rule (even at the beginning of the rhs of the
rule) and we may have more than one (or maybe zero) pieces of code in
a rule. The code is executed only when all the symbols at the left of
the code in the rhs of the rule have been processed.

<p>
It is very uncommon to build a full compiler by adding the appropriate
actions to productions. It is highly preferable to build the compiler
in stages. So a parser usually builds an Abstract Syntax Tree (AST)
and then, at a later stage of the compiler, these ASTs are compiled
into the target code. There is a fine distinction between parse trees
and ASTs. A parse tree has a leaf for each terminal and an internal
node for each nonterminal. For each production rule used, we create a
node whose name is the lhs of the rule and whose children are the
symbols of the rhs of the rule. An AST on the other hand is a compact
data structure to represent the same syntax regardless of the form of
the production rules used in building this AST.

</p><p>

</p><h2><a name="SECTION00051000000000000000">
4.1 Building Abstract Syntax Trees in Java</a>
</h2>

<p>
When building ASTs, it's a good idea to define multiple classes
to capture various families of constructs. For example, we
can have an <code>Exp</code> class to represent expressions, <code>Stmt</code> class to
represent statements, and <code>Type</code> class to represent types. 
Here is an example of <code>Exp</code> in Java:
</p><pre>abstract class Exp {
}
class IntegerExp extends Exp {
   public int value;
   public IntegerExp ( int n ) { value=n; }
}
class TrueExp extends Exp {
   public TrueExp () {}
}
class FalseExp extends Exp {
   public FalseExp () {}
}
class VariableExp extends Exp {
   public String value;
   public VariableExp ( String n ) { value=n; }
}
class BinaryExp extends Exp {
   public String operator;
   public Exp left;
   public Exp right;
   public BinaryExp ( String o, Exp l, Exp r ) { operator=o; left=l; right=r; }
}
class UnaryExp extends Exp {
   public String operator;
   public Exp operand;
   public UnaryExp ( String o, Exp e ) { operator=o; operand=e; }
}
class ExpList {
   public Exp head;
   public ExpList next;
   public ExpList ( Exp h, ExpList n ) { head=h; next=n; }
}
class CallExp extends Exp {
   public String name;
   public ExpList arguments;
   public CallExp ( String nm, ExpList s ) { name=nm; arguments=s; }
}
class ProjectionExp extends Exp {
   public Exp value;
   public String attribute;
   public ProjectionExp ( Exp v, String a ) { value=v; attribute=a; }
}
class RecordElements {
   public String attribute;
   public Exp value;
   public RecordElements next;
   public RecordElements ( String a, Exp v, RecordElements el )
          { attribute=a; value=v; next=el; }
}
class RecordExp extends Exp {
    public RecordElements elements;
    public RecordExp ( RecordElements el ) { elements=el; }
}
</pre>
For example,
<pre>new BinaryExp("+",new BinaryExp("-",new VariableExp("x"),new IntegerExp(2)),
              new IntegerExp(3))
</pre>
constructs the AST for the input <code>(x-2)+3</code>.

<p>

</p><h2><a name="SECTION00052000000000000000">
4.2 Building Abstract Syntax Trees in C</a>
</h2>

<p>
The previous example of expression ASTs can be written as follows in C:
</p><pre>typedef struct Exp {
  enum { int_exp, true_exp, false_exp, variable_exp,
         binary_op, unary_op, function_call,
         record_construction, projection } tag;
  union { int                                      integer;
          string                                   variable;
          struct { string           oper;
                   struct Exp*      left;
                   struct Exp*      right; }       binary;
          struct { string           oper;
                   struct Exp*      uexp; }        unary;
          struct { string           name;
                   struct Exp_list* arguments; }   call;
          struct rec { string       attribute;
                       struct Exp*  value;
                       struct rec*  next; }        record;
          struct { struct Exp*  value;
                   string attribute; }             project;
      } op;
} ast;
</pre>
where Exp_list is a list of ASTs:
<pre>typedef struct Exp_list { 
  ast*             elem;
  struct Exp_list* next;
} ast_list;
</pre>
It's a good idea to define a constructor for every kind of expression
to simplify the task of constructing ASTs:
<pre>ast* make_binary_op ( string oper, ast* left, ast* right ) {
  ast* e = (ast*) malloc(sizeof(ast));
  e-&gt;tag = binary_op;
  e-&gt;op.binary.oper = make_string(oper);
  e-&gt;op.binary.left = left;
  e-&gt;op.binary.right = right;
  return e;
};
</pre>
For example,
<pre>make_binary_op("+",make_binary_op("-",make_variable("x"),make_integer(2)),
               make_integer(3))
</pre>
constructs the AST for the input <code>(x-2)+3</code>.

<p>
Unfortunately, when constructing a compiler, we need to define many
tree-like data structures to capture ASTs for many different
constructs, such as expressions, statements, declarations, programs
etc, as well as type structures, intermediate representation (IR)
trees, etc.  This would require hundreds of recursive structs in C or
classes in Java.  An alternative method is to use just one generic
tree structure to capture all possible tree structures. This is
exactly what we did for our calculator example and is described in
detail below.

</p><p>

</p><h2><a name="SECTION00053000000000000000"></a><a name="calc-ast"></a>
<br>
4.3 Gen: A Java Package for Constructing and Manipulating Abstract Syntax Trees
</h2>

<p>
The code for the calculator example is written in Gen.
<em>Gen</em> is a Java preprocessor that adds syntactic constructs to the Java
language to make the task of handling Abstract Syntax Trees (ASTs)
easier. The class project will be developed using Gen.

</p><p>
Two classes are used by Gen, which are defined in
<a name="tex2html9" href="http://lambda.uta.edu/cse5317/Gen/Ast.java">Ast.java</a>:
the class <code>Ast</code> that captures an AST (with subclasses Variable, Number,
Real, Astring, and Node), and the class <code>Arguments</code> that captures
a list of ASTs.
An <code>Ast</code> is a tree-like data structure, which is used for representing 
various tree-like data structures used in compiler construction, including ASTs and Intermediate
Representation (IR) code.
</p><pre>abstract class Ast {
}
class Number extends Ast {
    public long value;
    public Number ( long n ) { value = n; }
}
class Real extends Ast {
    public double value;
    public Real ( double n ) { value = n; }
}
class Variable extends Ast {
    public String value;
    public Variable ( String s ) { value = s; }
}
class Astring extends Ast {
    public String value;
    public Astring ( String s ) { value = s; }
}
class Node extends Ast {
    public String name;
    public Arguments args;
    public Node ( String n, Arguments a ) { tag = n; args = a; }
}
</pre>
where the <code>Arguments</code> class represents a list of ASTs:
<pre>class Arguments {
    public Ast       head;
    public Arguments tail;
    public Arguments ( Ast h, Arguments t );
    public final static Arguments nil;
    public Arguments append ( Ast e );
}
</pre>
See the file <a name="tex2html10" href="http://lambda.uta.edu/cse5317/Gen/Ast.java">Ast.java</a>
for
a complete definition.

<p>
For example, the Java expression
</p><pre>new Node("Binop",
         Arguments.nil.append(new Variable("Plus"))
                      .append(new Variable("x"))
                      .append(new Node("Binop",
                              Arguments.nil.append(new Variable("Minus"))
                                           .append(new Variable("y"))
                                           .append(new Variable("z")))))
</pre>
constructs the AST <code>Binop(Plus,x,Binop(Minus,y,z))</code>.

<p>
The nice thing about this approach is that we do not need to add a new class to define
another tree-like data structure.  The disadvantage is that it's now easier to make mistakes
when writing programs to manipulate these tree structures.  For
example, we may pass a statement tree in a procedure that handles
expression trees and this will not be detected by the Java compiler.

</p><p>
To make the task of writing these
tree constructions less tedious, Gen extends Java with the syntactic form
<code>#&lt; &gt;</code>. For example, <code>#&lt;Binop(Plus,x,Binop(Minus,y,z))&gt;</code> is equivalent
to the above Java expression. That is, the text within the brackets <code>#&lt; &gt;</code>
is used by Gen to generate Java code, which creates the tree-like form
(an instance of the class <code>Ast</code>)
that represents this text. Values of the class <code>Ast</code>
can be included into the form generated by the <code>#&lt; &gt;</code> brackets by ``escaping"
them with a backquote character (<code>`</code>). The operand of the escape operator (the backquote operator)
is expected to be an expression of type <code>Ast</code> that provides the value to ``fill in"
the hole in the bracketed text at that point (actually, an escaped string/int/double is
also lifted to an Ast).
For example, in
</p><pre>  Ast x = #&lt;join(a,b,p)&gt;;
  Ast y = #&lt;select(`x,q)&gt;;
  Ast z = #&lt;project(`y,A)&gt;;
</pre>
<code>y</code> is set to <code>#&lt;select(join(a,b,p),q)&gt;</code> and
<code>z</code> to <code>#&lt;project(select(join(a,b,p),q),A)&gt;</code>.
There is also bracketed syntax, <code>#[ ]</code>, for constructing instances of Arguments.

<p>
The bracketed syntax has the following BNF:

</p><p>
</p><pre>bracketed ::=   "#&lt;" expr "&gt;"                   an AST construction
              | "#[" arg "," ... "," arg "]"    an Arguments construction
expr ::=   name                                 the representation of a variable name
         | integer                              the repr. of an integer
         | real                                 the repr. of a real number
         | string                               the repr. of a string
         | "`" name                             escaping to the value of \verb@name@
         | "`(" code ")"                        escaping to the value of \verb@code@
         | name "(" arg "," ... "," arg ")"     the repr. of an AST node with zero or more children
         | "`" name "(" arg "," ... "," arg ")" the repr. of an AST node with escaped name
         | expr opr expr                        an AST node that represents a binary infix operation
         | "`" name "[" expr "]"                variable substitution (explained later)
arg  ::=   expr                                 the repr. of an expression
         | "..." name                           escaping to a list of ASTs bound to \verb@name@
         | "...(" code ")"                      escaping to a list of ASTs returned by \verb@code@
</pre>

<p>
where <code>code</code> is any Java code.
The <code>#&lt; `(code) &gt;</code> embeds the value returned by the Java code <code>code</code> of type
<code>Ast</code> to the term representation inside the brackets.

</p><p>
For example, <code>#&lt;`f(6,...r,g("ab",`(k(x))),`y)&gt;</code> is equivalent to the
following Java code:
</p><pre>new Node(f,
    Arguments.nil.append(new Number(6))
                 .append(r)
                 .append(new Node("g",Arguments.nil.append(new Astring("ab"))
                                                   .append(k(x))))
                 .append(y)
</pre>
If <code>f="h"</code>, <code>y=#&lt;m(1,"a")&gt;</code>, and <code>k(x)</code>
returns the value <code>#&lt;8&gt;</code>, then the above term is equivalent to
<code>#&lt;h(6,g("ab",8),m(1,"a"))&gt;</code>.
The three dots (<code>...</code>) construct is used to indicate a list of children in an AST node.
Since this list is an instance of the class <code>Arguments</code>,
the type of <code>name</code> in <code>...name</code> is also <code>Arguments</code>.
For example, in
<pre>  Arguments r = #[join(a,b,p),select(c,q)];
  Ast z = #&lt;project(...r)&gt;;
</pre>
<code>z</code> will be bound to <code>#&lt;project(join(a,b,p),select(c,q))&gt;</code>.

<p>
Gen provides a case statement syntax with patterns.  Patterns match the
<code>Ast</code> representations with similar shape. Escape operators
applied to variables inside these patterns represent variable patterns, which
``bind" to corresponding subterms upon a successful match.
This capability makes it particularly easy to write functions
that perform source-to-source transformations. A function that simplifies
arithmetic expressions can be expressed easily as:
</p><pre>  Ast simplify ( Ast e ) {
    #case e
    |  plus(`x,0) =&gt; return x;
    |  times(`x,1) =&gt; return x;
    |  times(`x,0) =&gt; return #&lt;0&gt;;
    |  _ =&gt; return e;
    #end;
  }
</pre>
where the <code>_</code> pattern matches any value.
For example, <code>simplify(#&lt;times(z,1)&gt;)</code> returns <code>#&lt;z&gt;</code>,
since <code>times(z,1)</code> matches the second case pattern. The BNF of the case
statement is:

<p>
</p><pre>case_stmt ::= "#case" code case ... case "#end"
case    ::= "|" expr guard "=&gt;" code
guard   ::=   ":" code                          an optional condition
            |
expr ::=   name                                 exact match with a variable name
         | integer                              exact match with an integer
         | real                                 exact match with a real number
         | string                               exact match with a string
         | "`" name                             match with the value of \verb@name@
         | "`(" code ")"                        match with the value of \verb@code@
         | name "(" arg "," ... "," arg ")"     match with an AST node with zero or more children
         | "`" name "(" arg "," ... "," arg ")" match with an AST node with escaped name
         | expr opr expr                        an AST node that represents a binary infix operation
         | "`" name "[" expr "]"                second-order matching (explained later)
         | "_"                                  match any Ast
arg  ::=   expr                                 match with an Ast
         | "..." name                           match with a list of ASTs bound to \verb@name@
         | "...(" code ")"                      match with a list of ASTs returned by \verb@code@
         | "..."                                match the rest of the arguments
</pre>

<p>
For example, the pattern <code>`f(...r)</code> matches any Ast Node: when it is matched with
<code>#&lt;join(a,b,c)&gt;</code>, it binds <code>f</code> to the string <code>"join"</code>
and <code>r</code> to the Arguments <code>#[a,b,c]</code>.
Another example is the following function that adds the terms <code>#&lt;8&gt;</code> and <code>#&lt;9&gt;</code>
as children to any Node <code>e</code>:
</p><pre>  Ast add_arg ( Ast e ) {
    #case e
    |  `f(...r) =&gt; return #&lt;`f(8,9,...r)&gt;;
    |  `x =&gt; return x;
    #end;
  }
</pre>
As another example of a case statement in Gen, consider the following function, which
switches the inputs of a binary join found as a parameter to a
Node <code>e</code>:
<pre>  Ast switch_join_args ( Ast e ) {
    #case e
    |  `f(...r,join(`x,`y),...s) =&gt; return #&lt;`f(...r,join(`y,`x),...s)&gt;;
    |  `x =&gt; return x;
    #end;
  }
</pre>
The most powerful construct in Gen is second-order pattern
matching, denoted by the special syntax <code>`f[expr]</code>.  When
<code>`f[expr]</code> is matched against an <code>Ast</code>, <code>e</code>, it
traverses the entire tree representation of <code>e</code> (in preorder)
until it finds a tree node that matches the pattern <code>expr</code>.  It
fails when it does not find a match. When it finds a match, it
succeeds and binds the variables in the pattern <code>expr</code>.
Furthermore, it binds the variable <code>f</code> to a list of Ast (of
class Arguments) that represents the path from the root Ast to the Ast
node that matched the pattern. This is best used in conjuction with
the bracketed expression <code>`f[e]</code>, which uses the path bound in
<code>f</code> to construct a new Ast with <code>expr</code> replaced with
<code>e</code>.  For example, the Gen program
<pre>  Ast n = new_name();
  #case e
  |  `f[join(`x,`y)] =&gt; return #&lt;let(`n,join(`x,`y),`f[`n])&gt;;
  #end;
</pre>
extracts the first term that matches a join from the term <code>e</code> and
it pulls the term out in a let-binding.

<p>
Another syntactic construct in Gen is a for-loop that iterates over Arguments:
</p><pre>"#for" name "in" code "do" code "#end"
</pre>
For example,
<pre>#for v in #[a,b,c] do
   System.out.println(v);
#end;
</pre>

<p>

</p><h1><a name="SECTION00060000000000000000">
5 Semantic Actions</a>
</h1>

<p>
Let's consider now how actions are evaluated by different parsers.
In recursive descent parsers, actions are pieces of code embedded in
the recursive procedures. For the following grammar:

</p><p>
</p><pre>E ::= T E'
E' ::= + T E'
     | - T E'
     |
T ::= num
</pre>
we have the following recursive descent parser:

<p>
</p><pre>int E () { return Eprime(T()); };
int Eprime ( int left ) {
  if (current_token=='+') {
     read_next_token();
     return Eprime(left + T());
  } else if (current_token=='-') {
     read_next_token();
     return Eprime(left - T());
  } else return left;
};
int T () {
  if (current_token=='num') {
     read_next_token();
     return num_value;
  } else error();
};
</pre>
By passing <code>T()</code> as input to <code>Eprime</code>, we pass the left operand to <code>Eprime</code>.

<p>
Table-driven predictive parsers use the parse stack to push/pop
actions (along with symbols) but they use a separate semantic stack to
execute the actions.  In that case, the parsing algorithm becomes:

</p><p>
</p><pre>push(S);
read_next_token();
repeat
  X = pop();
  if (X is a terminal or '$')
     if (X == current_token)
        read_next_token();
     else error();
  else if (X is an action)
     perform the action;
  else if (M[X,current_token] == "X ::= Y1 Y2 ... Yk")
     {  push(Yk);
        ...
        push(Y1);
     }
  else error();
until X == '$';
</pre>

<p>
For example, suppose that <code>pushV</code> and <code>popV</code> are the
functions to manipulate the semantic stack. The following is the grammar of
an interpreter that uses the semantic stack to perform additions and
subtractions:
</p><pre>E ::= T E' $ { print(popV()); }
E' ::= + T { pushV(popV() + popV()); } E'
     | - T { pushV(-popV() + popV()); } E'
     |
T ::= num { pushV(num); }
</pre>
For example, for <code>1+5-2</code>, we have the following sequence of actions:
<pre>pushV(1); pushV(5); pushV(popV()+popV()); pushV(3);
pushV(-popV()+popV()); print(popV());
</pre>
Question: what would happen if we put the action of the second rule at the end of rhs?

<p>
In contrast to top-down parsers, bottom-up parsers can only perform an
action after a reduction (ie, after the entire rhs of a rule has been
processed). Why? because at a particular instance of time we may have
a potential for multiple rules for reduction (this is the idea behind
itemsets), which means that we may be in the middle of many rules at a
time, but later only one rule will actually be used; so, we can't
execute an action in the middle of a rule because we may have to undo
it later if the rule is not used for reduction. This means that we can
only have rules of the form
</p><pre>X ::= Y1 ... Yn { action }
</pre>
where the action is always at the end of the rule. This action is
evaluated after the rule <code>X ::= Y1 ... Yn</code> is reduced.  To
evaluate actions, in addition to state numbers, the parser pushes
values into the parse stack: Both terminals and non-terminals are
associated with typed values, which in the CUP parser generator are
instances of the Object class (or of some subclass of the Object
class).  Since the Java Object class is a superclass of all classes,
it doesn't carry any additional information, but the subclasses of
Object, such as the class Integer, the class String, and the class Ast
for ASTs, do.  The value associated with a terminal is in most cases
an Object, except for an identifier which is a String, for an integer
which is an Integer, etc. The typical values associated with
non-terminals in a compiler are ASTs, lists of ASTs, etc.
In CUP, you can retrieve the value of a symbol <code>s</code> at the lhs of a rule by using the
notation <code>s:x</code>, where @x@ is a variable name that hasn't appeared
elsewhere in this rule. The value of the non-terminal defined by a rule
is called <code>RESULT</code> and should always be assigned a value in the action.
For example, if the non-terminal <code>E</code> is associated with an integer value
(of type <code>Integer</code>), then the following rule:
<pre>E ::= E:n PLUS E:m    {: RESULT = n+m; :}
</pre>
retrieves the value, <code>n</code>, of the left operand from the parse
stack, retrieves the value, <code>m</code>, of the right operand from the
parse stack, and pushes the value of <code>RESULT</code> on the parse stack,
which has been set to <code>n+m</code> after the reduction of the rule. That
is, the elements of the parser stack in CUP are pairs of a
state-number (integer) and an Object. So when the above rule is
reduced, the three top elements of the stack, which form the handle of
the reduction, will contain three elements: the state reached when we
reduced the rule for <code>E</code> to get the left operand, the state for
shifting over <code>PLUS</code>, and the state reached when we reduced the
rule for <code>E</code> to get the right operand (top of stack). Along with
these states, there are three Objects: one bound to <code>n</code>, one
ignored (since the terminal <code>PLUS</code> is associated with an empty
Object, which is ignored), and one bound to <code>m</code> (top of stack).
When we reduce by the above rule, we use the GOTO table to find which
state to push, we pop the handle (three elements), and we push the
pair of this state and the <code>RESULT</code> value on the parse stack.

<p>
If we want build an AST in CUP, we need to associate each
non-terminal symbol with an AST type. For example, if we use the non-terminals
<code>exp</code> and <code>expl</code> for expressions and list of expressions respectively, we can
define their types as follows:
</p><pre>non terminal Ast	exp;
non terminal Arguments	expl;
</pre>
Then the production rules should have actions to build ASTs:
<pre>exp ::= exp:e1 PLUS exp:e2    {: RESULT = new Node(plus_exp,e1,e2); :}
    |   exp:e1 MINUS exp:e2   {: RESULT = new Node(minus_exp,e1,e2); :}
    |   id:nm LP expl:el RP   {: RESULT = new Node(call_exp,el.reverse()
                                                .cons(new Variable(nm))); :}
    |   INT:n                 {: RESULT = new Number(n.intValue()); :}
    ;
expl ::= expl:el COMMA exp:e  {: RESULT = el.cons(e); :}
     |   exp:e                {: RESULT = nil.cons(e); :}
     ;
</pre>
That is, for integer addition, we build an AST node that corresponds to
a binary operation (see the AST in Section&nbsp;<a href="#ast-syntax">4</a>).

<p>
What if we want to put an action in the middle of the rhs of a rule
in a bottom-up parser? In that case we use a dummy nonterminal,
called a <em>marker</em>. For example,
</p><pre>X ::= a { action } b
</pre>
is equivalent to
<pre>X ::= M b
M ::= a { action }
</pre>
This is done automatically by the CUP parser generator (ie, we can actually
put actions in the middle of a rhs of a rule and CUP will use
the above trick to put it at the end of a rule).  There is a danger
though that the resulting rules may introduce new shift/reduce or
reduce/reduce conflicts.

<p>

</p><h1><a name="SECTION00070000000000000000">
6 Semantic Analysis</a>
</h1>

<p>

</p><h2><a name="SECTION00071000000000000000">
6.1 Symbol Tables</a>
</h2>

<p>
After ASTs have been constructed, the compiler must check whether the
input program is type-correct. This is called <em>type checking</em> and
is part of the semantic analysis. During type checking, a compiler
checks whether the use of names (such as variables, functions, type
names) is consistent with their definition in the program. For
example, if a variable <code>x</code> has been defined to be of type
<code>int</code>, then <code>x+1</code> is correct since it adds two integers while
<code>x[1]</code> is wrong. When the type checker detects an inconsistency,
it reports an error (such as ``Error: an integer was expected").
Another example of an inconsistency is calling a function with fewer or
more parameters or passing parameters of the wrong type.

</p><p>
Consequently, it is necessary to remember declarations so that we can
detect inconsistencies and misuses during type checking.  This is the
task of a <em>symbol table</em>. Note that a symbol table is a
compile-time data structure. It's not used during run time by statically typed
languages. Formally, a symbol table maps names into
declarations (called attributes), such as mapping the
variable name <code>x</code> to its type <code>int</code>. More specifically,
a symbol table stores:

</p><ul>
<li>for each type name, its type definition (eg. for the C type declaration
<code>typedef int* mytype</code>, it maps the name <code>mytype</code> to a data structure
that represents the type <code>int*</code>).
</li>
<li>for each variable name, its type. If the variable is an array, it also stores dimension information.
It may also store storage class, offset in activation record etc.
</li>
<li>for each constant name, its type and value.
</li>
<li>for each function and procedure, its formal parameter list and its output type.
Each formal parameter must have name, type, type of passing (by-reference or by-value), etc.
</li>
</ul>

<p>
One convenient data structure for symbol tables is a hash table.
One organization of a hash table that resolves conflicts is chaining.
The idea is that we have list elements of type:
</p><pre>class Symbol {
    public String key;
    public Object binding; 
    public Symbol next;
    public Symbol ( String k, Object v, Symbol r ) { key=k; binding=v; next=r; }
}
</pre>
to link key-binding mappings. 
Here a binding is any <code>Object</code>, but it can be more specific (eg, a <code>Type</code>
class to represent a type or a <code>Declaration</code> class, as we will see below). The hash table is a vector
<code>Symbol[]</code> of size <code>SIZE</code>, where <code>SIZE</code> is a prime
number large enough to have good performance for medium size programs
(eg, <code>SIZE=109</code>). The hash function must map any key (ie. any
string) into a bucket (ie. into a number between 0 and <code>SIZE-1</code>).
A typical hash function is, <code>h(key) = num(key) mod SIZE</code>,
where <code>num</code> converts a key to an integer and <code>mod</code> is the modulo operator.
In the beginning, every bucket is null. When we insert a new mapping
(which is a pair of key-binding), we calculate the bucket location by
applying the hash function over the key, we insert the key-binding
pair into a <code>Symbol</code> object, and we insert the object at
the beginning of the bucket list.  When we want to find the binding of
a name, we calculate the bucket location using the hash function, and
we search the element list of the bucket from the beginning to its end
until we find the first element with the requested name.

<p>
Consider the following Java program:
</p><pre>1) { 
2)   int a;
3)   {
4)     int a;
5)     a = 1;
6)   };
7)   a = 2;
8) };
</pre>
The statement <code>a = 1</code> refers to the second integer <code>a</code>, while
the statement <code>a = 2</code> refers to the first. This is called
a <em>nested scope</em> in programming languages. We need to modify the
symbol table to handle structures and we need to implement the following operations
for a symbol table:

<ul>
<li><code>insert ( String key, Object binding )</code>
</li>
<li><code>Object lookup ( String key )</code>
</li>
<li><code>begin_scope ()</code>
</li>
<li><code>end_scope ()</code>
</li>
</ul>

<p>
We have already seen <code>insert</code> and <code>lookup</code>. When we have a new block
(ie, when we encounter the token <code>{</code>), we begin a new
scope. When we exit a block (ie.  when we encounter the token
<code>}</code>) we remove the scope (this is the <code>end_scope)</code>.  When we
remove a scope, we remove all declarations inside this scope.  So
basically, scopes behave like stacks. One way to implement these
functions is to use a stack of numbers (from 0 to <code>SIZE</code>) that
refer to bucket numbers.  When we begin a new scope we push a special
marker to the stack (eg, -1).  When we insert a new declaration in
the hash table using <code>insert</code>, we also push the bucket number to
the stack. When we end a scope, we pop the stack until and including
the first -1 marker. For each bucket number we pop out from the stack,
we remove the head of the binding list of the indicated bucket number.
For example, for the previous C program, we have the following
sequence of commands for each line in the source program (we assume that
the hash key for <code>a</code> is 12):
</p><pre>1) push(-1)
2) insert the binding from a to int into the beginning of the list table[12]
   push(12)
3) push(-1)
4) insert the binding from a to int into the beginning of the list table[12]
   push(12)
6) pop()
   remove the head of table[12]
   pop()
7) pop()
   remove the head of table[12]
   pop()
</pre>
Recall that when we search for a declaration using lookup, we search the
bucket list from the beginning to the end, so that if we have multiple
declarations with the same name, the declaration in the innermost scope
overrides the declaration in the outer scope.

<p>
The textbook makes an improvement to the above data structure for
symbol tables by storing all keys (strings) into another data
structure and by using pointers instead of strings for keys in the
hash table. This new data structure implements a set of strings
(ie. no string appears more than once). This data structure too can be
implemented using a hash table. The symbol table itself uses the
physical address of a string in memory as the hash key to locate the
bucket of the binding. Also the key component of <code>element</code> is a
pointer to the string.  The idea is that not only we save space, since
we store a name once regardless of the number of its occurrences in a program,
but we can also calculate the bucket location very fast.

</p><p>

</p><h2><a name="SECTION00072000000000000000">
6.2 Types and Type Checking</a>
</h2>

<p>
A typechecker is a function that maps an AST that represents an
expression into its type. For example, if variable <code>x</code> is an
integer, it will map the AST that represents the expression <code>x+1</code>
into the data structure that represents the type <code>int</code>.  If there
is a type error in the expression, such as in <code>x&gt;"a"</code>, then it
displays an error message (a type error). So before we describe the
typechecker, we need to define the data structures for types. Suppose
that we have five kinds of types in the language: integers, booleans,
records, arrays, and named types (ie. type names that have been
defined earlier by some typedef). Then one possible data structure for
types is:

</p><p>
</p><pre>abstract class Type {
}
class IntegerType extends Type {
   public IntegerType () {}
}
class BooleanType extends Type {
   public BooleanType () {}
}
class NamedType extends Type {
   public String name;
   public NamedType ( String n ) { value=n; }
}
class ArrayType extends Type {
   public Type element;
   public ArrayType ( Type et ) { element=et; }
}
class RecordComponents {
   public String attribute;
   public Type type;
   public RecordComponents next;
   public RecordComponents ( String a, Type t, RecordComponents el )
          { attribute=a; type=t; next=el; }
}
class RecordType extends Type {
    public RecordComponents elements;
    public RecordType ( RecordComponents el ) { elements=el; }
}
</pre>
that is, if the type is an integer or a boolean, there are no extra
components. If it is a named type, we have the name of the type. If it
is an array, we have the type of the array elements (assuming that the
size of an array is unbound, otherwise we must include the array
bounds). If it is a record, we have a list of attribute/types (the
<code>RecordComponents</code> class) to capture the record components.

<p>
The symbol table must contain type declarations (ie. typedefs),
variable declarations, constant declarations, and function signatures.
That is, it should map strings (names) into <code>Declaration</code> objects:

</p><p>
</p><pre>abstract class Declaration {
}
class TypeDeclaration extends Declaration {
   public Type declaration;
   public TypeDeclaration ( Type t ) { declaration=t; }
}
class VariableDeclaration extends Declaration {
   public Type declaration;
   public VariableDeclaration ( Type t ) { declaration=t; }
}
class ConstantDeclaration extends Declaration {
   public Type declaration;
   public Exp value;
   public ConstantDeclaration ( Type t, Exp v ) { declaration=t; value=v; }
}
class TypeList {
   public Type head;
   public TypeList next;
   public TypeList ( Type h, TypeList n ) { head=h; next=n; }
}
class FunctionDeclaration extends Declaration {
   public Type result;
   public TypeList parameters;
   public FunctionDeclaration ( Type t, TypeList tl ) { result=t; parameters=tl; }
}
</pre>

<p>
If we use the hash table with chaining implementation, the symbol
table <code>symbol_table</code> would look like this:

</p><p>
</p><pre>class Symbol {
    public String key;
    public Declaration binding; 
    public Symbol next;
    public Symbol ( String k, Declaration v, Symbol r )
            { key=k; binding=v; next=r; }
}
Symbol[] symbol_table = new Symbol[SIZE];
</pre>
Recall that the symbol table should support the following operations:
<pre>insert ( String key, Declaration binding )
Declaration lookup ( String key )
begin_scope ()
end_scope ()
</pre>

<p>
The typechecking function may have the following signature:

</p><p>
</p><pre>static Type typecheck ( Exp e );
</pre>
The function <code>typecheck</code> must be recursive since the AST structure is
recursive.  In fact, this function is a tree traversals that checks
each node of the AST tree recursively.  The body of the typechecker
may look like this:

<p>
</p><pre>static Type typecheck ( Exp e ) {
   if (e instanceof IntegerExp)
      return new IntegerType();
   else if (e instanceof TrueExp)
      return new BooleanType();
   else if (e instanceof FalseExp)
      return new BooleanType();
   else if (e instanceof VariableExp) {
      VariableExp v = (VariableExp) e;
      Declaration decl = lookup(v.value);
      if (decl == null)
         error("undefined variable");
      else if (decl instanceof VariableDeclaration)
         return ((VariableDeclaration) decl).declaration;
      else error("this name is not a variable name");
   } else if (e instanceof BinaryExp) {
      BinaryExp b = (BinaryExp) e;
      Type left = typecheck(b.left);
      Type right = typecheck(b.right);
      switch ( b.operator ) {
         case "+": if (left instanceof IntegerType
                       &amp;&amp; right instanceof IntegerType)
                      return new IntegerType();
                   else error("expected integers in addition");
         ...
      }
   } else if (e instanceof CallExp) {
      CallExp c = (CallExp) e;
      Declaration decl = lookup(c.name);
      if (decl == null)
         error("undefined function");
      else if (!(decl instanceof FunctionDeclaration))
         error("this name is not a function name");
      FunctionDeclaration f = (FunctionDeclaration) decl;
      TypeList s = f.parameters;
      for (ExpList r=c.arguments; r!=null &amp;&amp; s!=null; r=r.next, s=s.next)
          if (!equal_types(s.head,typecheck(r.head)))
             error("wrong type of the argument in function call")
      if (r != null || s != null)
         error("wrong number of parameters");
      return f.result;
   }
   else ...
}
</pre>
where <code>equal_types(x,y)</code> checks the types <code>x</code> and <code>y</code>
for equality. We have two types of type equality: type equality based
on type name equivalence, or based on structural equivalence.  For
example, if we have defined <code>T</code> to be a synonym for the type
<code>int</code> and have declared the variable <code>x</code> to be of type
<code>T</code>, then using the first type of equality, <code>x+1</code> will cause a
type error (since <code>T</code> and <code>int</code> are different names), while
using the second equality, it will be correct.

<p>
Note also that since most realistic languages support many binary and
unary operators, it will be very tedious to hardwire their
typechecking into the typechecker using code. Instead, we can use
another symbol table to hold all operators (as well as all the system
functions) along with their signatures. This also makes the
typechecker easy to change.

</p><p>

</p><h2><a name="SECTION00073000000000000000">
6.3 Case Study: The Calculator Interpreter</a>
</h2>

<p>
In Section&nbsp;<a href="#calc-ast">4.3</a>, we described Gen used in constructing ASTs for the
calculator example.  We are now ready to go back to the calculator
parser <a name="tex2html11" href="http://lambda.uta.edu/cse5317/calc/calc.gen">calc.gen</a>
to see how ASTs are
constructed. Most nonterminals and some terminals have a type:
</p><pre>terminal String         ID;
terminal Integer        INT;
terminal Float          REALN;
terminal String         STRINGT;
non terminal Ast        exp, string, name;
non terminal Arguments  expl, names;
non terminal            item, prog;
</pre>
For example, each production for the nonterminal <code>exp</code>
constructs a value of type <code>Ast</code> when is reduced.  For example,
the following line in the calculator parser:
<pre>    |   exp:e1 PLUS exp:e2  {: RESULT = #&lt;plus_exp(`e1,`e2)&gt;; :}
</pre>
constructs a new <code>Ast</code> for <code>exp</code> when the rule is reduced.
This <code>Ast</code>, which is assigned to the variable <code>RESULT</code>, is a
tree node with label <code>plus_exp</code> and two children, <code>e1</code> and
<code>e2</code>, which correspond to the <code>Ast</code>s of the plus operands.

<p>
Recall that our calculator is an interpreter, rather than a compiler.
The symbol table of an interpreter must bind each program variable
to both its type and its value.  For example, when the interpret
encounters the variable <code>x</code> in a program, it must assert the type
of <code>x</code> (eg, an integer) so it can tell if <code>x</code> is used
correctly in the program. It also needs the value of <code>x</code> because
it needs to evaluate <code>x</code>. A compiler would only need the type of
<code>x</code>. Fortunately, our calculator has only one type: double
floating points.  So there is no need for type information since
everything is expected to be (or be able to be converted to) a
floating point. The calculator symbol table 
is an instance of the class <code>SymbolTable</code> given in
<a name="tex2html12" href="http://lambda.uta.edu/cse5317/Gen/SymbolTable.java">SymbolTable.java</a>.
It is a hash table with items of type <code>SymbolCell</code>:
</p><pre>class SymbolCell {
    String     name;
    Ast        binding; 
    SymbolCell next;
    SymbolCell ( String n, Ast v, SymbolCell r ) { name=n; binding=v; next=r; }
}
</pre>
The binding is the actual value of the symbol, not its type.  If we
had multiple types, we should have had another attribute <code>type</code>
of type <code>Ast</code> in <code>Symbol</code>. The binding plays two roles: if
the <code>name</code> is a variable name, then the binding is the actual
value (a double floating point number) represented by a
<code>Real</code> AST node. If the <code>name</code> is a function
definition, then the binding is the AST of the actual definition.
To implement variable scoping, a scope stack is used as it is
described in the previous section. The special marker -1 in the scope
stack indicates a new scope. All the other entries are locations in
the symbol table.

<p>
The interpreter code is given in 
<a name="tex2html13" href="http://lambda.uta.edu/cse5317/calc/Eval.gen">Eval.gen</a>.
Function <code>eval</code> evaluates the AST <code>e</code> using the symbol table
<code>st</code> and returns a double floating point number.  When a variable
is encountered, its value is retrieved from the symbol table.  A
function call can be either a primitive operation, such as an integer
addition, or a call to a defined function. In either case, the
function arguments must be evaluated before the operation/call is
performed.  The function call is performed by creating a new scope,
binding the functions' formal parameters to the evaluated call
arguments, and evaluating the function body using the new scope. After
the call, the function scope is popped out.

</p><p>

</p><h1><a name="SECTION00080000000000000000"></a><a name="actrec"></a>
<br>
7 Activation Records
</h1>

<p>

</p><h2><a name="SECTION00081000000000000000">
7.1 Run-Time Storage Organization</a>
</h2>

<p>
An executable program generated by a compiler will have the following
organization in memory on a typical architecture (such as on MIPS):

</p><p>
<img src="compiler_files/stack.gif" alt="stack.gif" align="BOTTOM" border="0" height="336" width="210">

</p><p>
This is the layout in memory of an executable program.  Note that in a
virtual memory architecture (which is the case for any modern
operating system), some parts of the memory layout may in fact be
located on disk blocks and they are retrieved in memory by demand
(lazily).

</p><p>
The machine code of the program is typically located at the
lowest part of the layout.  Then, after the code, there is a section
to keep all the fixed size static data in the program. The dynamically
allocated data (ie. the data created using <code>malloc</code> in C) as well
as the static data without a fixed size (such as arrays of variable
size) are created and kept in the heap. The heap grows from low to
high addresses.  When you call <code>malloc</code> in C to create a
dynamically allocated structure, the program tries to find an empty
place in the heap with sufficient space to insert the new data; if it
can't do that, it puts the data at the end of the heap and increases
the heap size. 

</p><p>
The focus of this section is the stack in the memory layout.  It is
called the <em>run-time stack</em>.  The stack, in contrast to the heap, grows
in the opposite direction (upside-down): from high to low addresses,
which is a bit counterintuitive. The stack is not only used to push
the return address when a function is called, but it is also used for
allocating some of the local variables of a function during the
function call, as well as for some bookkeeping.

</p><p>
Lets consider the lifetime of a function call.  When you call a
function you not only want to access its parameters, but you may also
want to access the variables local to the function. Worse, in a nested
scoped system where nested function definitions are allowed, you may
want to access the local variables of an enclosing function.  In
addition, when a function calls another function, we must forget about
the variables of the caller function and work with the variables of
the callee function and when we return from the callee, we want to
switch back to the caller variables. That is, function calls behave in
a stack-like manner. Consider for example the following program:

</p><p>
</p><pre>procedure P ( c: integer )
  x: integer;

  procedure Q ( a, b: integer )
  i, j: integer;
  begin
    x := x+a+j;
  end;

begin
  Q(x,c);
end;
</pre>

<p>
At run-time, <code>P</code> will execute the statement <code>x := x+a+j</code> in
<code>Q</code>.  The variable <code>a</code> in this statement comes as a
parameter to <code>Q</code>, while <code>j</code> is a local variable in <code>Q</code>
and <code>x</code> is a local variable to <code>P</code>. How do we organize the
runtime layout so that we will be able to access all these variables
at run-time? The answer is to use the run-time stack.

</p><p>
When we call a function <code>f</code>, we push a new <em>activation
record</em> (also called a <em>frame</em>) on the run-time stack, which is
particular to the function <code>f</code>. Each frame can occupy many
consecutive bytes in the stack and may not be of a fixed
size. When the callee function returns to the caller, the activation
record of the callee is popped out.  For example, if the main program
calls function <code>P</code>, <code>P</code> calls <code>E</code>, and <code>E</code> calls
<code>P</code>, then at the time of the second call to <code>P</code>, there will
be 4 frames in the stack in the following order: <code>main</code>,
<code>P</code>, <code>E</code>, <code>P</code>

</p><p>
Note that a callee should not make any assumptions about who is the
caller because there may be many different functions that call the
same function. The frame layout in the stack should reflect this.
When we execute a function, its frame is located on top of the stack.
The function does not have any knowledge about what the previous
frames contain. There two things that we need to do though when
executing a function: the first is that we should be able to pop-out
the current frame of the callee and restore the caller frame. This can
be done with the help of a pointer in the current frame, called the
<em>dynamic link</em>, that points to the previous frame (the caller's
frame).  Thus all frames are linked together in the stack using
dynamic links.  This is called the <em>dynamic chain</em>. When we pop
the callee from the stack, we simply set the stack pointer to be the
value of the dynamic link of the current frame. The second thing that
we need to do, is if we allow nested functions, we need to be able to
access the variables stored in previous activation records in the
stack. This is done with the help of the <em>static link</em>. Frames
linked together with static links form a <em>static chain</em>.  The
static link of a function <code>f</code> points to the latest frame in the
stack of the function that statically contains <code>f</code>.
If <code>f</code> is not lexically contained in any other function, its
static link is null. For example, in the previous program, if <code>P</code>
called <code>Q</code> then the static link of <code>Q</code> will point to the
latest frame of <code>P</code> in the stack (which happened to be the
previous frame in our example). Note that we may have multiple frames
of <code>P</code> in the stack; <code>Q</code> will point to the latest.  Also
notice that there is no way to call <code>Q</code> if there is no <code>P</code>
frame in the stack, since <code>Q</code> is hidden outside <code>P</code> in the
program.

</p><p>
A typical organization of a frame is the following:

</p><p>
<img src="compiler_files/frame.gif" alt="frame.gif" align="BOTTOM" border="0" height="393" width="335">

</p><p>
Before we create the frame for the callee, we need to allocate space
for the callee's arguments. These arguments belong to the caller's
frame, not to the callee's frame. There is a frame pointer (called
<code>FP</code>) that points to the beginning of the frame. The stack
pointer points to the first available byte in the stack immediately
after the end of the current frame (the most recent frame).  There are
many variations to this theme. Some compilers use <em>displays</em> to
store the static chain instead of using static links in the stack.  A
display is a register block where each pointer points to a consecutive
frame in the static chain of the current frame. This allows a very
fast access to the variables of deeply nested functions. Another
important variation is to pass arguments to functions using registers.

</p><p>
When a function (the caller) calls another function (the callee),
it executes the following code before (the pre-call) and after (the post-call)
the function call:

</p><ul>
<li><em>pre-call:</em> allocate the callee frame on top of the stack; evaluate and store function parameters
in registers or in the stack; store the return address to the caller in a register or in the stack.
</li>
<li><em>post-call:</em> copy the return value; deallocate (pop-out) the callee frame; restore
parameters if they passed by reference.
</li>
</ul>
In addition, each function has the following code in the beginning (prologue) and at
the end (epilogue) of its execution code:

<ul>
<li><em>prologue:</em> store frame pointer in the stack or in a display; set the frame pointer to be the top of the stack;
store static link in the stack or in the display; initialize local variables.
</li>
<li><em>epilogue:</em> store the return value in the stack; restore frame pointer; return to the caller.
</li>
</ul>

<p>
We can classify the variables in a program into four categories:

</p><ul>
<li>statically allocated data that reside in the static data part of the program;
these are the global variables.
</li>
<li>dynamically allocated data that reside in the heap;
these are the data created by malloc in C.
</li>
<li>register allocated variables that reside in the CPU registers;
these can be function arguments, function return values, or local variables.
</li>
<li>frame-resident variables that reside in the run-time stack;
these can be function arguments, function return values, or local variables.
</li>
</ul>

<p>
Every frame-resident variable (ie. a local variable) can be
viewed as a pair of (level,offset).  The variable level indicates the
lexical level in which this variable is defined.  For example, the
variables inside the top-level functions (which is the case for all
functions in C) have level=1. If a function is nested inside a
top-level function, then its variables have level=2, etc. The offset
indicates the relative distance from the beginning of the frame that
we can find the value of a variable local to this frame. For example,
to access the <i>n</i>th argument of the frame in the above figure, we
retrieve the stack value at the address <code>FP+1</code>, and to access the
first argument, we retrieve the stack value at the address <code>FP+n</code>
(assuming that each argument occupies one word).  When we want to
access a variable whose level is different from the level of the
current frame (ie. a non-local variable), we subtract the level of the
variable from the current level to find out how many times we need to
follow the static link (ie. how deep we need to go in the static
chain) to find the frame for this variable. Then, after we locate the
frame of this variable, we use its offset to retrieve its value from
the stack. For example, to retrieve to value of <code>x</code> in the
<code>Q</code> frame, we follow the static link once (since the level of
<code>x</code> is 1 and the level of <code>Q</code> is 2) and we retrieve <code>x</code>
from the frame of <code>P</code>.

</p><p>
Another thing to consider is what exactly do we pass as arguments to
the callee.  There are two common ways of passing arguments: by value
and by reference. When we pass an argument by reference, we actually
pass the address of this argument. This address may be an address in
the stack, if the argument is a frame-resident variable.  A
third type of passing arguments, which is not used anymore but it was
used in Algol, is call by name. In that case we create a <em>thunk</em>
inside the caller's code that behaves like a function and contains the
code that evaluates the argument passed by name. Every time the callee
wants to access the call-by-name argument, it calls the thunk to
compute the value for the argument.

</p><p>

</p><h2><a name="SECTION00082000000000000000">
7.2 Case Study: Activation Records for the MIPS Architecture</a>
</h2>

<p>
The following describes a function call abstraction for the MIPS
architecture.  This may be slightly different from the one you will
use for the project.

</p><p>
MIPS uses the register <code>$sp</code> as the stack pointer and the
register <code>$fp</code> as the frame pointer. In the following MIPS code
we use both a dynamic link and a static link embedded in the
activation records.

</p><p>
Consider the previous program:

</p><p>
</p><pre>procedure P ( c: integer )
  x: integer;

  procedure Q ( a, b: integer )
  i, j: integer;
  begin
    x := x+a+j;
  end;

begin
  Q(x,c);
end;
</pre>

<p>
The activation record for <code>P</code> (as <code>P</code> sees it) is shown in the first figure below:

</p><p>
<img src="compiler_files/mips_call.gif" alt="mips_call.gif" align="BOTTOM" border="0" height="394" width="468">

</p><p>
The activation record for <code>Q</code> (as <code>Q</code> sees it) is shown in the second figure above.
The third figure shows the structure of the run-time stack at the point where
<code>x := x+a+j</code> is executed. This statement uses <code>x</code>, which is defined
in <code>P</code>. We can't assume that <code>Q</code> called <code>P</code>, so we should not use
the dynamic link to retrieve <code>x</code>; instead, we need to use the static link,
which points to the most recent activation record of <code>P</code>.
Thus, the value of variable <code>x</code> is computed by:
</p><pre>        lw        $t0, -8($fp)                # follow the static link of Q
        lw        $t1, -12($t0)               # x has offset=-12 inside P
</pre>
Function/procedure arguments are pushed in the stack before the function call.
If this is a function, then an empty placeholder (4 bytes) should be pushed in the stack
before the function call; this will hold the result of the function.

<p>
Each procedure/function should begin with the following code (prologue):
</p><pre>        sw      $fp, ($sp)      # push old frame pointer (dynamic link)
        move    $fp, $sp        # frame pointer now points to the top of stack
        subu    $sp, $sp, 500   # allocate say 500 bytes in the stack
                                #   (for frame size = 500)
        sw      $ra, -4($fp)    # save return address in frame
        sw      $v0, -8($fp)    # save static link in frame
</pre>
(where <code>$v0</code> is set by the caller - see below) and should end with the following code (epilogue):
<pre>        lw      $ra, -4($fp)    # restore return address
        move    $sp, $fp        # pop frame
        lw      $fp, ($fp)      # restore old frame pointer (follow dynamic link)
        jr      $ra             # return
</pre>
For each procedure call, you need to push the arguments into the stack
and set <code>$v0</code> to be the right static link (very often it is equal
to the static link of the current procedure; otherwise,
you need to follow the static link a number of times).
For example, the call <code>Q(x,c)</code> in <code>P</code> is translated into:
<pre>        lw      $t0, -12($fp)
        sw      $t0, ($sp)        # push x
        subu    $sp, $sp, 4
        lw      $t0, 4($fp)
        sw      $t0, ($sp)        # push c
        subu    $sp, $sp, 4
        move    $v0, $fp          # load static link in $v0
        jal     Q                 # call procedure Q
        addu    $sp, $sp, 8       # pop stack
</pre>
Note that there are two different cases for setting the static link before a procedure call.
Lets say that caller_level and callee_level are the nesting
levels of the caller and the callee procedures (recall that the nesting
level of a top-level procedure is 0, while the nesting level of
a nested procedure embedded inside another procedure with nesting level <i>l</i>, is <i>l</i> + 1).
When the callee is lexically inside the caller's body, that is, when callee_level=caller_level+1, we have:
<pre>        move    $v0, $fp
</pre>
The call <code>Q(x,c)</code> in <code>P</code> is such a case because the nesting levels of <code>P</code> and <code>Q</code>
are 0 and 1, respectively.
Otherwise, we follow the static link of the caller <i>d</i> + 1 times, where <i>d</i>=caller_level-callee_level (the difference
between the nesting level of the caller from that of the callee). For d=0, that is, when both caller
and callee are at the same level, we have
<pre>        lw        $v0, -8($fp)
</pre>
For d=2 we have
<pre>        lw        $t1, -8($fp)
        lw        $t1, -8($t1)
        lw        $v0, -8($t1)
</pre>
These cases are shown in the following figure:

<p>
<img src="compiler_files/static_link.gif" alt="static_link.gif" align="BOTTOM" border="0" height="302" width="693">

</p><p>
Note also that, if you have a call to a function, you need to allocate 4 more bytes in the stack
to hold the result.

</p><p>
See <a name="tex2html14" href="http://lambda.uta.edu/cse5317/spring98/note2.html">the factorial example</a>
for 
a concrete example of a function expressed in MIPS code.

</p><p>

</p><h1><a name="SECTION00090000000000000000">
8 Intermediate Code</a>
</h1>

<p>
The semantic phase of a compiler first translates parse trees into an
intermediate representation (IR), which is independent of the
underlying computer architecture, and then generates machine code from
the IRs. This makes the task of retargeting the compiler to another
computer architecture easier to handle. 

</p><p>
We will consider Tiger for a case study.  For simplicity, all data are
one word long (four bytes) in Tiger.  For example, strings, arrays,
and records, are stored in the heap and they are represented by one
pointer (one word) that points to their heap location.  We also assume
that there is an infinite number of temporary registers (we will see
later how to spill-out some temporary registers into the stack
frames). The IR trees for Tiger are used for building expressions and
statements.  They are described in detail in Section 7.1 in the
textbook. Here is a brief description of the meaning of the expression IRs:

</p><ul>
<li>CONST(i): the integer constant i.
</li>
<li>MEM(e): if e is an expression that calculates a memory address, then this is the contents
  of the memory at address e (one word).
</li>
<li>NAME(n): the address that corresponds to the label n, eg. MEM(NAME(x)) returns the value stored at the location X.
</li>
<li>TEMP(t): if t is a temporary register, return the value of the register, eg. 
<pre>MEM(BINOP(PLUS,TEMP(fp),CONST(24)))
</pre>
fetches a word from the stack located 24 bytes above the frame pointer.
</li>
<li>BINOP(op,e1,e2): evaluate e1, then evaluate e2, and finally perform the binary operation op over
the results of the evaluations of e1 and e2. op can be PLUS, AND, etc.
We abbreviate BINOP(PLUS,e1,e2) as +(e1,e2).
</li>
<li>CALL(f,[e1,e2,...,en]): evaluate the expressions e1, e2, etc (in that order), and at the
end call the function f over these n parameters. eg. 
<pre>CALL(NAME(g),ExpList(MEM(NAME(a)),ExpList(CONST(1),NULL)))
</pre>
represents the function call g(a,1).
</li>
<li>ESEQ(s,e): execute statement s and then evaluate and return the value of the expression e
</li>
</ul>
And here is the description of the statement IRs:

<ul>
<li>MOVE(TEMP(t),e): store the value of the expression e into the register t.
</li>
<li>MOVE(MEM(e1),e2): evaluate e1 to get an address, then evaluate e2, and then store the value of e2
in the address calculated from e1. eg, 
<pre>MOVE(MEM(+(NAME(x),CONST(16))),CONST(1))
</pre>
computes x[4] := 1 (since 4*4bytes = 16 bytes).
</li>
<li>EXP(e): evaluates e and discards the result.
</li>
<li>JUMP(L): Jump to the address L (which must be defined in the program by some LABEL(L)).
</li>
<li>CJUMP(o,e1,e2,t,f): evaluate e1, then e2. The binary relational operator o must be EQ, NE, LT etc.
If the values of e1 and e2 are related by o, then jump to the address calculated by t, else jump the one for f.
</li>
<li>SEQ(s1,s2,...,sn): perform statement s1, s2, ... sn is sequence.
</li>
<li>LABEL(n): define the name n to be the address of this statement. You can retrieve this address using NAME(n).
</li>
</ul>

<p>
In addition, when JUMP and CJUMP IRs are first constructed, the labels
are not known in advance but they will be known later when they are
defined. So the JUMP and CJUMP labels are first set to NULL and then
later, when the labels are defined, the NULL values are changed to
real addresses.

</p><p>

</p><h2><a name="SECTION00091000000000000000">
8.1 Translating Variables, Records, Arrays, and Strings</a>
</h2>

<p>
Local variables located in the stack are retrieved using an expression
represented by the IR: MEM(+(TEMP(fp),CONST(offset))).  If a variable
is located in an outer static scope k levels lower than the current
scope, the we retrieve the variable using the IR:
</p><pre>MEM(+(MEM(+(...MEM(+(MEM(+(TEMP(fp),CONST(static))),CONST(static))),...)),
      CONST(offset)))
</pre>
where static is the offset of the static link.  That is, we follow the
static chain k times, and then we retrieve the variable using the
offset of the variable.

<p>
An <em>l-value</em> is the result of an expression that can occur on the
left of an assignment statement. eg, x[f(a,6)].y is an l-value. It
denotes a location where we can store a value. It is basically
constructed by deriving the IR of the value and then dropping the outermost
MEM call. For example, if the value is MEM(+(TEMP(fp),CONST(offset))),
then the l-value is +(TEMP(fp),CONST(offset)).

</p><p>
In Tiger (the language described in the textbook), vectors start from index 0 and each vector element is 4
bytes long (one word), which may represent an integer or a pointer to
some value.  To retrieve the <i>i</i>th element of an array <i>a</i>, we use
MEM(+(A,*(I,4))), where A is the address of <i>a</i> (eg. A is
+(TEMP(fp),CONST(34))) and I is the value of <i>i</i>
(eg. MEM(+(TEMP(fp),CONST(26)))). But this is not sufficient. The IR
should check whether <i>a</i> &lt; <i>size</i>(<i>a</i>):
CJUMP(gt,I,CONST(size_of_A),MEM(+(A,*(I,4))),NAME(error_label)), that
is, if <i>i</i> is out of bounds, we should raise an exception.

</p><p>
For records, we need to know the byte offset of each field (record
attribute) in the base record. Since every value is 4 bytes long, the
<i>i</i>th field of a structure a can be retrieved using
MEM(+(A,CONST(i*4))), where A is the address of <i>a</i>.  Here <i>i</i> is
always a constant since we know the field name.  For example, suppose
that <i>i</i> is located in the local frame with offset 24 and <i>a</i> is
located in the immediate outer scope and has offset 40. Then the
statement <code>a[i+1].first := a[i].second+2</code>
is translated into the IR: 
</p><pre>MOVE(MEM(+(+(TEMP(fp),CONST(40)),
           *(+(MEM(+(TEMP(fp),CONST(24))),
              CONST(1)),
             CONST(4)))),
     +(MEM(+(+(+(TEMP(fp),CONST(40)),
               *(MEM(+(TEMP(fp),CONST(24))),
                 CONST(4))),
             CONST(4))),
       CONST(2)))
</pre>
since the offset of first is 0 and the offset of second is 4.

<p>
In Tiger, strings of size <i>n</i> are allocated in the heap in <i>n</i> + 4 consecutive
bytes, where the first 4 bytes contain the size of the string. The
string is simply a pointer to the first byte. String literals
are statically allocated. For example, the MIPS code:
</p><pre>ls:     .word        14
        .ascii       "example string"
</pre>
binds the static variable <code>ls</code> into a string with 14 bytes.
Other languages, such as C, store a string of size <i>n</i> into a dynamically
allocated storage in the heap of size <i>n</i> + 1 bytes.
The last byte has a null value to indicate the end of string.
Then, you can allocate a string with address <i>A</i> of size <i>n</i> in the heap by adding <i>n</i> + 1 to
the global pointer ($gp in MIPS):
<pre>MOVE(A,ESEQ(MOVE(TEMP(gp),+(TEMP(gp),CONST(n+1))),TEMP(gp)))
</pre>

<p>

</p><h2><a name="SECTION00092000000000000000">
8.2 Control Statements</a>
</h2>

<p>
Statements, such as for-loop and while-loop, are translated into IR
statements that contain jumps and conditional jumps.

</p><p>
The while loop <code>while c do body;</code>
is evaluated in the following way:
</p><pre>loop: if c goto cont else goto done
cont: body
      goto loop
done:
</pre>
which corresponds to the following IR:
<pre>SEQ(LABEL(loop),
    CJUMP(EQ,c,1,NAME(done),NAME(cont)),
    LABEL(cont),
    s,
    JUMP(NAME(loop)),
    LABEL(done))
</pre>
The for statement <code>for i:=lo to hi do body</code> 
is evaluated in the following way:
<pre>      i := lo
      j := hi
      if i&gt;j goto done
loop: body
      i := i+1
      if i&lt;=j goto loop
done:
</pre>
The <code>break</code> statement is translated into a JUMP. The compiler
keeps track which label to JUMP to on a ``break" statement by
maintaining a stack of labels that holds the ``done:" labels of the
for- or while-loop.  When it compiles a loop, it pushes the label in
the stack, and when it exits a loop, it pops the stack. The
<code>break</code> statement is thus translated into a JUMP to the label at
the top of the stack.

<p>
A function call <code>f(a1,...,an)</code> is translated into the IR
<code>CALL(NAME(l_f),[sl,e1,...,en])</code>, where <code>l_r</code> is the label
of the first statement of the <code>f</code> code, <code>sl</code> is the static
link, and <code>ei</code> is the IR for <code>ai</code>. For example, if the
difference between the static levels of the caller and callee is one,
then <code>sl</code> is <code>MEM(+(TEMP(fp),CONST(static)))</code>, where
<code>static</code> is the offset of the static link in a frame. That is, we
follow the static link once. The code generated for the body of the
function <code>f</code> is a sequence which contains the prolog, the code of
<code>f</code>, and the epilogue, as it was discussed in Section&nbsp;<a href="#actrec">7</a>.

</p><p>
For example, suppose that records and vectors are implemented as pointers
(i.e. memory addresses) to dynamically allocated data in the heap. Consider
the following declarations:

</p><p>
</p><pre>struct { X: int, Y: int, Z: int } S;      /* a record */
int i;
int V[10][10];                            /* a vector of vectors */
</pre>
where the variables <code>S</code>, <code>i</code>, and <code>V</code> are stored
in the current frame with offsets -16, -20, and -24 respectively.
By using the following abbreviations:

<p>
</p><pre>S = MEM(+(TEMP(fp),CONST(-16)))
I = MEM(+(TEMP(fp),CONST(-20)))
V = MEM(+(TEMP(fp),CONST(-24)))
</pre>
we have the following IR translations:

<p>
</p><pre>S.Z+S.X
  --&gt; +(MEM(+(S,CONST(8))),MEM(S))

if (i&lt;10) then S.Y := i else i := i-1
  --&gt; SEQ(CJUMP(LT,I,CONST(10),trueL,falseL),
          LABEL(trueL),
          MOVE(MEM(+(S,CONST(4))),I),
          JUMP(exit),
          LABEL(falseL),
          MOVE(I,-(I,CONST(1))),
          JUMP(exit),
          LABEL(exit))

V[i][i+1] := V[i][i]+1
  --&gt; MOVE(MEM(+(MEM(+(V,*(I,CONST(4)))),*(+(I,CONST(1)),CONST(4)))),
           MEM(+(MEM(+(V,*(I,CONST(4)))),*(I,CONST(4)))))

for i:=0 to 9 do V[0][i] := i
  --&gt; SEQ(MOVE(I,CONST(0)),
          MOVE(TEMP(t1),CONST(9)),
          CJUMP(GT,I,TEMP(t1),done,loop),
          LABEL(loop),
          MOVE(MEM(+(MEM(V),*(I,CONST(4)))),I),
          MOVE(I,+(I,CONST(1))),
          CJUMP(LEQ,I,TEMP(t1),loop,done),
          LABEL(done))
</pre>

<p>

</p><h1><a name="SECTION000100000000000000000">
9 Basic Blocks and Traces</a>
</h1>

<p>
Many computer architectures have instructions that do not exactly
match the IR representations given in the previous sections. For
example, they do not support two-way branching as in
<code>CJUMP(op,e1,e2,l1,l2)</code>.  In addition, nested calls, such as
<code>CALL(f,[CALL(g,[1])])</code>, will cause interference between register
arguments and returned results.  The nested SEQs, such as
<code>SEQ(SEQ(s1,s2),s3)</code>, impose an order of a evaluation, which
restricts optimization (eg, if <code>s1</code> and <code>s2</code> do not
interfere with each other, we would like to be able to switch
<code>SEQ(s1,s2)</code> with <code>SEQ(s2,s1)</code> because it may result to a
more efficient program.

</p><p>
The problems mentioned above can be eliminated in two phases:

</p><ol>
<li>transforming IR trees into a list of  <em>canonical trees</em>, and
</li>
<li>transforming unrestricted CJUMPs into CJUMPs that are followed by their false target label.
</li>
</ol>
An IR is a canonical tree if it does not contain SEQ or ESEQ and the parent
node of each CALL node is either an EXP or a MOVE(TEMP(t),...) node.
The idea is that we transform an IR in such a way that all ESEQs are pulled up
in the IR and become SEQs at the top of the tree. At the end, we are left
with nested SEQs at the top of the tree, which are eliminated
to form a list of statements. For example, the IR:
<pre>SEQ(MOVE(NAME(x),ESEQ(MOVE(TEMP(t),CONST(1)),TEMP(t))),
    JUMP(ESEQ(MOVE(NAME(z),NAME(L)),NAME(z))))
</pre>
is translated into:
<pre>SEQ(SEQ(MOVE(TEMP(t),CONST(1)),
        MOVE(NAME(x),TEMP(t)))
    SEQ(MOVE(NAME(z),NAME(L)),
        JUMP(NAME(z))))
</pre>
which corresponds to a list of statements (if we remove the top SEQs):
<pre>[ MOVE(TEMP(t),CONST(1)), MOVE(NAME(x),TEMP(t)), 
  MOVE(NAME(z),NAME(L)), JUMP(NAME(z)) ]
</pre>
Here are some rules to make canonical trees:

<ul>
<li>ESEQ(s1,ESEQ(s2,e)) = ESEQ(SEQ(s1,s2),e)
</li>
<li>BINOP(op,ESEQ(s,e1),e2) = ESEQ(s,BINOP(op,e1,e2))
</li>
<li>MEM(ESEQ(s,e)) = ESEQ(s,MEM(e))
</li>
<li>JUMP(ESEQ(s,e)) = SEQ(s,JUMP(e))
</li>
<li>CJUMP(op,ESEQ(s,e1),e2,l1,l2) = SEQ(s,CJUMP(op.e1,e2,l1,l2))
</li>
<li>BINOP(op,e1,ESEQ(s,e2))
<br>= ESEQ(MOVE(temp(t),e1),ESEQ(s,BINOP(op,TEMP(t),e2)))
</li>
<li>CJUMP(op,e1,ESEQ(s,e2),l1,l2)
<br>= SEQ(MOVE(temp(t),e1),SEQ(s,CJUMP(op,TEMP(t),e2,l1,l2)))
</li>
<li>MOVE(ESEQ(s,e1),e2) = SEQ(s,MOVE(e1,e2))
</li>
</ul>
To handle function calls, we store the function results into a new register:

<p>
CALL(f,a) = ESEQ(MOVE(TEMP(t),CALL(f,a)),TEMP(t))

</p><p>
That way expressions, such as <code>+(CALL(f,a),CALL(g,b))</code>, would not
rewrite each others result register.

</p><p>
Now the next thing to do is to transform any CJUMP into a CJUMP whose
false target label is the next instruction after CJUMP. This reflects
the conditional JUMP found in most architectures (ie. ``if condition
then JUMP label").  To do so, we first form <em>basic blocks</em> from
the IR tree.  A basic block is a sequence of statements whose first
statement is a LABEL, the last statement is a JUMP or CJUMP, and does
not contain any other LABELs, JUMPs, or CJUMPs. That is, we can only
enter at the beginning of a basic block and exit at the end.  To solve
the CJUMP problem, we first create the basic blocks for an IR tree and
then we reorganize the basic blocks in such a way that every CJUMP at
the end of a basic block is followed by a block the contains the CJUMP
false target label. A secondary goal is to put the target of a JUMP
immediately after the JUMP. That way, we can eliminate the JUMP (and
maybe merge the two blocks). The algorithm is based on <em>traces</em>:
You start a trace with an unmark block and you consider the target of
the JUMP of this block or the false target block of its CJUMP.  Then,
if the new block is unmarked, you append the new block to the trace,
you use it as your new start, and you apply the algorithm recursively;
otherwise, you close this trace and you start a new trace by going
back to a point where there was a CJUMP and you choose the true target
this time. You continue until all blocks are marked. This is a greedy
algorithm. At the end, there may be still some CJUMPs that have a
false target that does not follow the CJUMP (this is the case where
this false target label was the target of another JUMP or CJUMP found
earlier in a trace). In that case:

</p><ul>
<li>if we have a CJUMP followed by a true target, we negate the condition and switch the true and false targets;
</li>
<li>otherwise, we create a new block LABEL(L) followed by JUMP(F)
and we replace CJUMP(op,a,b,T,F) with CJUMP(op,a,b,T,L).
</li>
</ul>
Also, if there is a JUMP(L) followed by a LABEL(L), we remove the JUMP.

<p>

</p><h1><a name="SECTION000110000000000000000">
10 Instruction Selection</a>
</h1>

<p>
After IR trees have been put into a canonical form (described in the
previous section), they are used in generating assembly code. The
obvious way to do this is to macroexpand each IR tree node. For
example, <code>MOVE(MEM(+(TEMP(fp),CONST(10))),CONST(3))</code>
is macroexpanded into the pseudo-assembly code at the right column:
</p><pre>TEMP(fp)                                t1 := fp
CONST(10)                               t2 := 10
+(TEMP(fp),CONST(10))                   t3 := t1+t2
CONST(3)                                t4 := 3
MOVE(MEM(...),CONST(3))                 M[t3] := t4
</pre>
where ti stands for a temporary variable.
This method generates very poor quality code. For example,
the IR above can be done using only one instruction in most architectures: <code>M[fp+10] := 3</code>.

<p>
A method, called <em>maximum munch</em>, generates better code,
especially for RISC machines. The idea is to use tree pattern matching
to map a tree pattern (a fragment of an IR tree) into a list of
assembly instructions. These tree patterns are called <em>tiles</em>.
For RISC we always have one-to-one mapping (one tile to one assembly
instruction).  Note that for RISC machines the tiles are small (very
few number of IR nodes) but for CISC machines the tiles are usually
large since the CISC instructions are very complex.

</p><p>
The following is the mapping of some tiles (left) into MIPS code (right):
</p><pre>CONST(c)                                li   'd0, c
+(e0,e1)                                add  'd0, 's0, 's1
+(e0,CONST(c))                          add  'd0, 's0, c
*(e0,e1)                                mult 'd0, 's0, 's1
*(e0,CONST(2^k))                        sll  'd0, 's0, k
MEM(e0)                                 lw   'd0, ('s0)
MEM(+(e0,CONST(c)))                     lw   'd0, c('s0)
MOVE(MEM(e0),e1)                        sw   's1, ('s0)
MOVE(MEM(+(e0,CONST(c))),e1)            sw   's1, c('s0)
JUMP(NAME(X))                           b    X
JUMP(e0)                                jr   's0
LABEL(X)                           X:   nop
</pre>
Here <code>e0</code> and <code>e1</code> are subtrees of these IR tree nodes. Most
of the assembly instructions above have one destination register
<code>d0</code> and a number of source registers, <code>s0</code> and
<code>s1</code>. So if a tree pattern, such as <code>MOVE(MEM(e0),e1)</code>, has
two input subtrees <code>e0</code> and <code>e1</code>, then their values are
taken from the source registers <code>s0</code> and <code>s1</code> (which are the
destinations of <code>e0</code> and <code>e1</code>). The quote in the assembly
instructions is used to indicate that temporary registers should be
selected so that there is this match of source-destination names.

<p>
To translate an IR tree into assembly code, we perform a <em>tiling</em>:
we cover the IR tree with non-overlapping tiles.
We can see that there are many different tilings.
Consider for example the tiger statement <code>a[i] := x</code>, where
<code>i</code> is a temporary register, the <code>a</code> address is stored at the
offset 20, and <code>x</code> at the offset 10. The IR form is:
</p><pre>MOVE(MEM(+(MEM(+(fp,CONST(20))),*(TEMP(i),CONST(4)))),MEM(+(fp,CONST(10))))
</pre>
The following are two possible tilings of the IR:
<pre>   lw   r1, 20($fp)                     add  r1, $fp, 20
   sll  r2, r1, 2                       lw   r1, (r1)
   add  r1, r1, r2                      sll  r2, r1, 2
   lw   r2, 10($fp)                     add  r1, r1, r2
   sw   r2, (r1)                        add  r2, $fp, x
                                        lw   r2, (r2)
                                        sw   r2, (r1)
</pre>
The first tiling is obviously better since it can be executed faster.

<p>
It's highly desirable to do <em>optimum tiling</em>, ie, to generate the
shortest instruction sequence (or alternatively the sequence with the
fewest machine cycles). But this is not always easy to achieve.  So
most compilers do an <em>optimal tiling</em> where no two adjacent tiles
can be combined into a tile of lower cost. Optimum tiling is not
always optimal but it's close for RISC machines.

</p><p>
There are two main ways of performing optimum tiling: using <em>maximal munch</em> (a greedy algorithm) or using dynamic programming. In
maximal munch you start from the IR root and from all matching tiles
you select the one with the maximum number of IR nodes (largest tile).
Then you go to the children (subtrees) of this tile and apply the
algorithm recursively until you reach the tree leaves. The dynamic programming
works from the leaves to the root. It assigns a cost to every tree node
by considering every tile that matches the node and calculating the minimum value of:
</p><div align="CENTER">
cost of a node = (number of nodes in the tile) + (total costs of all the tile children)

</div>
(the costs of the tile children are known since the algorithm is bottom-up).

<p>
For example, consider the following IR represented as a tree and its tiling using maximal munch:

</p><p>
<img src="compiler_files/tiling.gif" alt="tiling.gif" align="BOTTOM" border="0" height="289" width="410">

</p><p>
The order of tiling is IEHBDGACF (ie, top-down).
After we set the tiles, we use a different register <code>ri</code> for each connection
between the tiles. Then we expand the tiles into MIPS code by following the tile mapping table.
The order of tile expansion is ABCDEFGHI (ie, bottom-up).
The MIPS code is:

</p><p>
</p><pre>A      lw   r1, fp
B      lw   r2, 8(r1)
C      lw   r3, i
D      sll  r4, r3, 2
E      add  r5, r2, r4
F      lw   r6, fp
G      lw   r7, 16(r6)
H      add  r8, r7, 1
I      sw   r8, (r5)
</pre>

<p>

</p><h1><a name="SECTION000120000000000000000">
11 Liveness Analysis</a>
</h1>

<p>
When we generated IR trees, we assumed that we have a very large number
of temporary variables stored in registers.  Of course this is not true for real
machines. In particular CISC machines have very few registers (Pentium
has 6 general registers only).  So it's highly desirable to use one
machine register for multiple temporary variables (instead of using
one register for one temporary variable). Consider this program:
</p><pre>1.     a := 0
2. L1: b := a+1
3.     c := c+b
4.     a := b*2
5.     if a&lt;10 goto L1
6.     return c
</pre>
Obviously we need a maximum of three registers, one for each variable
<code>a</code>, <code>b</code>, and <code>c</code>.  But we can do better if we use
two registers: one for <code>c</code> and one for both <code>a</code> and
<code>b</code>.  This is possible because after <code>a+1</code> is computed in statement 2 and during statements 3 and 4, the
value of <code>a</code> is not used, and these are the only places where
<code>b</code> is used. We say that variables <code>a</code> and <code>b</code> do not
<em>interfere</em> if they are not <em>live</em> during the same periods in
the program.  In that case, they can occupy the same
register.  A variable <code>x</code> is <em>live</em> at a particular point
(statement) in a program, if it holds a value that may be needed in
the future. That is, <code>x</code> is live at a particular point if there is a path
(possibly following gotos) from this point to a statement that uses <code>x</code> and
there is no assignment to <code>x</code> in any statement in the path
(because if there was an assignment to <code>x</code>, the old value of
<code>x</code> is discarded before it is used).  For example, <code>a</code> is
live in 2 (because it's the place where it is used), not live in 3 and 4
(because it is assigned a value in 4 before it is used in 5), and live
again in 5. Variable <code>b</code> is live in 3 and 4 only, and variable
<code>c</code> is live in 2, 3, 4, 5, and 6 (it's live in 2 because there is a path
to 3 where it is used). In general, let's say that you have a use
of a variable <code>v</code> in line <code>n</code>:
<pre>k.    v := ...
      ...
n.    x := ... v ..
</pre>
(Here <code>v</code> is used in the source of an assignment but it may have also been
used in a function call, return statement, etc.) We try to find an
assignment <code>v := ...</code> such that there is path from this statement
to line <code>n</code> and there is no other assignment to <code>v</code>
along this path. In that case, we say that <code>v</code> is live
along this path (immediately after the asignment until and
including line <code>n</code>). We do that for every use of <code>v</code>
and the union of all these regions in which <code>v</code> is live gives
us the life of <code>v</code>. In our example, the life of variables are:
<br><table border="1" cellpadding="3">
<tbody><tr><td align="CENTER">&nbsp;</td>
<td align="CENTER">a</td>
<td align="CENTER">b</td>
<td align="CENTER">c</td>
</tr>
<tr><td align="CENTER">1</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">X</td>
</tr>
<tr><td align="CENTER">2</td>
<td align="CENTER">X</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">X</td>
</tr>
<tr><td align="CENTER">3</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">X</td>
<td align="CENTER">X</td>
</tr>
<tr><td align="CENTER">4</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">X</td>
<td align="CENTER">X</td>
</tr>
<tr><td align="CENTER">5</td>
<td align="CENTER">X</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">X</td>
</tr>
<tr><td align="CENTER">6</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">X</td>
</tr>
</tbody></table>
<br>
<p>
Let's formalize the liveness of a variable.  The first thing to do is
to construct the <em>control flow graph</em> (CFG) of a program. The CFG
nodes are individual statements (or maybe basic blocks) and the graph
edges represent potential flow of control.  The outgoing edges of a
node <i>n</i> are <i>succ</i>[<i>n</i>] and the ingoing edges are <i>pred</i>[<i>n</i>]. For
example, <!-- MATH
 $succ[5]=[6,2]$
 -->
<i>succ</i>[5] = [6, 2] and <!-- MATH
 $pred[5]=[4]$
 -->
<i>pred</i>[5] = [4].  For each CFG node <i>n</i> (a
statement) we define <i>use</i>[<i>n</i>] to be all the variables used (read) in
this statement and <i>def</i>[<i>n</i>] all the variables assigned a value
(written) in this statement. For example, <!-- MATH
 $use[3]=[b,c]$
 -->
<i>use</i>[3] = [<i>b</i>, <i>c</i>] and
<!-- MATH
 $def[3]=[c]$
 -->
<i>def</i>[3] = [<i>c</i>].

</p><p>
We say that variable <i>v</i> is live at a statement <i>n</i> if there is a path
in the CFG from this statement to a statement <i>m</i> such that <!-- MATH
 $v\in
use[m]$
 -->
<i>v</i> <img src="compiler_files/img3.png" alt="$ \in$" align="MIDDLE" border="0" height="24" width="13"> <i>use</i>[<i>m</i>] and for each <!-- MATH
 $n\leq k< m:\, v\not\in def[k]$
 -->
<i>n</i> <img src="compiler_files/img10.png" alt="$ \leq$" align="MIDDLE" border="0" height="24" width="14"> <i>k</i> &lt; <i>m</i> : &nbsp;<i>v</i> <img src="compiler_files/img11.png" alt="$ \not\in$" align="MIDDLE" border="0" height="26" width="13"><i>def</i>[<i>k</i>].  That is, there
is no assignment to <i>v</i> in the path from <i>n</i> to <i>m</i>.  For example,
<code>c</code> is alive in 4 since it is used in 6 and there is no
assignment to <code>c</code> in the path from 4 to 6.

</p><p>
The <em>liveness analysis</em> analyzes a CFG to determine which places
variables are live or not. It is a data flow analysis since it flows
around the edges of the CFG information about variables (in this case
information about the liveness of variables). For each CFG node <i>n</i> we
derive two sets: <i>in</i>[<i>n</i>] (live-in) and <i>out</i>[<i>n</i>] (live-out). The set
<i>in</i>[<i>n</i>] gives all variables that are live before the execution of
statement <i>n</i> and <i>out</i>[<i>n</i>] gives all variables that are live after the
execution of statement <i>n</i>. So the goal here is to compute these sets
from the sets <i>succ</i>, <i>use</i> and <i>def</i>. To do this, we consider the
properties of <i>in</i> and <i>out</i>:

</p><ol>
<li><!-- MATH
 $v\in use[n]\Rightarrow v\in in[n]$
 -->
<i>v</i> <img src="compiler_files/img3.png" alt="$ \in$" align="MIDDLE" border="0" height="24" width="13"> <i>use</i>[<i>n</i>] <img src="compiler_files/img12.png" alt="$ \Rightarrow$" align="BOTTOM" border="0" height="12" width="17"> <i>v</i> <img src="compiler_files/img3.png" alt="$ \in$" align="MIDDLE" border="0" height="24" width="13"> <i>in</i>[<i>n</i>]. That is, if <i>v</i> is used in <i>n</i> then is live-in in <i>n</i>
(regardless whether it is defined in <i>n</i>).
</li>
<li><!-- MATH
 $v\in (out[n]-def[n]) \Rightarrow v\in in[n]$
 -->
<i>v</i> <img src="compiler_files/img3.png" alt="$ \in$" align="MIDDLE" border="0" height="24" width="13"> (<i>out</i>[<i>n</i>] - <i>def</i>[<i>n</i>]) <img src="compiler_files/img12.png" alt="$ \Rightarrow$" align="BOTTOM" border="0" height="12" width="17"> <i>v</i> <img src="compiler_files/img3.png" alt="$ \in$" align="MIDDLE" border="0" height="24" width="13"> <i>in</i>[<i>n</i>]. That is, if <i>v</i> is live
after the execution of <i>n</i> and is not defined in <i>n</i>, then <i>v</i> is live before
the execution of <i>n</i>.
</li>
<li>for each <!-- MATH
 $s\in succ[n]:\; v\in in[s]\Rightarrow v\in out[n]$
 -->
<i>s</i> <img src="compiler_files/img3.png" alt="$ \in$" align="MIDDLE" border="0" height="24" width="13"> <i>succ</i>[<i>n</i>] : &nbsp;<i>v</i> <img src="compiler_files/img3.png" alt="$ \in$" align="MIDDLE" border="0" height="24" width="13"> <i>in</i>[<i>s</i>] <img src="compiler_files/img12.png" alt="$ \Rightarrow$" align="BOTTOM" border="0" height="12" width="17"> <i>v</i> <img src="compiler_files/img3.png" alt="$ \in$" align="MIDDLE" border="0" height="24" width="13"> <i>out</i>[<i>n</i>]. This
reflects the formal definition of the liveness of variable <i>v</i>.
</li>
</ol>
The algorithm to compute <i>in</i> and <i>out</i> is the following:
<!-- MATH
 \begin{displaymath}
\begin{array}{l}
{\bf foreach}\; n:\; in[n]\leftarrow\emptyset; out[n]\leftarrow\emptyset\\
{\bf repeat}\\
\hspace{3ex} {\bf foreach}\; n:\\
\hspace{10ex} in'[n] \leftarrow in[n]\\
\hspace{10ex} out'[n] \leftarrow out[n]\\
\hspace{10ex} in[n] \leftarrow use[n]\cup (out[n]-def[n])\\
\hspace{10ex} out[n] \leftarrow \bigcup_{s\in succ[n]} in[s]\\
{\bf until}\; in'=in \wedge out'=out
\end{array}
\end{displaymath}
 -->
<p></p>
<div align="CENTER">
<table>
<tbody><tr valign="MIDDLE"><td align="LEFT"><img src="compiler_files/img13.png" alt="$\displaystyle \bf foreach$" align="MIDDLE" border="0" height="26" width="53"> &nbsp;<i>n</i> : &nbsp;<i>in</i>[<i>n</i>] <img src="compiler_files/img14.png" alt="$\displaystyle \leftarrow$" align="MIDDLE" border="0" height="24" width="17"> <img src="compiler_files/img15.png" alt="$\displaystyle \emptyset$" align="MIDDLE" border="0" height="27" width="10">;<i>out</i>[<i>n</i>] <img src="compiler_files/img14.png" alt="$\displaystyle \leftarrow$" align="MIDDLE" border="0" height="24" width="17"> <img src="compiler_files/img15.png" alt="$\displaystyle \emptyset$" align="MIDDLE" border="0" height="27" width="10"></td>
</tr>
<tr valign="MIDDLE"><td align="LEFT"><img src="compiler_files/img16.png" alt="$\displaystyle \bf repeat$" align="MIDDLE" border="0" height="24" width="48"></td>
</tr>
<tr valign="MIDDLE"><td align="LEFT">&nbsp; <img src="compiler_files/img13.png" alt="$\displaystyle \bf foreach$" align="MIDDLE" border="0" height="26" width="53"> &nbsp;<i>n</i> :</td>
</tr>
<tr valign="MIDDLE"><td align="LEFT">&nbsp; <i>in'</i>[<i>n</i>] <img src="compiler_files/img14.png" alt="$\displaystyle \leftarrow$" align="MIDDLE" border="0" height="24" width="17"> <i>in</i>[<i>n</i>]</td>
</tr>
<tr valign="MIDDLE"><td align="LEFT">&nbsp; <i>out'</i>[<i>n</i>] <img src="compiler_files/img14.png" alt="$\displaystyle \leftarrow$" align="MIDDLE" border="0" height="24" width="17"> <i>out</i>[<i>n</i>]</td>
</tr>
<tr valign="MIDDLE"><td align="LEFT">&nbsp; <i>in</i>[<i>n</i>] <img src="compiler_files/img14.png" alt="$\displaystyle \leftarrow$" align="MIDDLE" border="0" height="24" width="17"> <i>use</i>[<i>n</i>] <img src="compiler_files/img17.png" alt="$\displaystyle \cup$" align="MIDDLE" border="0" height="24" width="13"> (<i>out</i>[<i>n</i>] - <i>def</i>[<i>n</i>])</td>
</tr>
<tr valign="MIDDLE"><td align="LEFT">&nbsp; <i>out</i>[<i>n</i>] <img src="compiler_files/img14.png" alt="$\displaystyle \leftarrow$" align="MIDDLE" border="0" height="24" width="17"> <img src="compiler_files/img18.png" alt="$\displaystyle \bigcup_{{s\in succ[n]}}^{}$" align="MIDDLE" border="0" height="43" width="46"><i>in</i>[<i>s</i>]</td>
</tr>
<tr valign="MIDDLE"><td align="LEFT"><img src="compiler_files/img19.png" alt="$\displaystyle \bf until$" align="MIDDLE" border="0" height="26" width="36"> &nbsp;<i>in'</i> = <i>in</i> <img src="compiler_files/img20.png" alt="$\displaystyle \wedge$" align="MIDDLE" border="0" height="24" width="13"> <i>out'</i> = <i>out</i></td>
</tr>
</tbody></table>
</div><p></p>
That is, we store the old values of <i>in</i> and <i>out</i> into <i>in'</i> and
<i>out'</i> and we repeatedly execute the loop until we can't add any more
elements.  The algorithm converges very fast if we consider the CFG
nodes in the reverse order (when is possible), ie, in the order 6, 5,
4, 3, 2, 1. See Table 10.6 in the textbook for an example.

<p>
The life of a variable can be directly derived from vector <i>in</i>:
if <!-- MATH
 $v\in in[n]$
 -->
<i>v</i> <img src="compiler_files/img3.png" alt="$ \in$" align="MIDDLE" border="0" height="24" width="13"> <i>in</i>[<i>n</i>] then <i>v</i> is live on line <i>n</i>.
Then, from the variable lifes we can compute the <em>interference graph</em>.
The nodes of this graph are the program variables and for
each node <i>v</i> and <i>w</i> there is an interference edge if the lives of
the variables <i>v</i> and <i>w</i> overlap in at least one program point (statement).  For each CFG
node <i>n</i> that assigns the value to the variable <i>a</i> (ie, <!-- MATH
 $a\in
def[n]$
 -->
<i>a</i> <img src="compiler_files/img3.png" alt="$ \in$" align="MIDDLE" border="0" height="24" width="13"> <i>def</i>[<i>n</i>]) we add the edges <!-- MATH
 $(a,b_1),\,(a,b_2),\ldots,(a,b_m)$
 -->
(<i>a</i>, <i>b</i><sub>1</sub>),&nbsp;(<i>a</i>, <i>b</i><sub>2</sub>),...,(<i>a</i>, <i>b</i><sub>m</sub>), where
<!-- MATH
 $out[n]=\{b_1,b_2,\ldots,b_m\}$
 -->
<i>out</i>[<i>n</i>] = {<i>b</i><sub>1</sub>, <i>b</i><sub>2</sub>,..., <i>b</i><sub>m</sub>}. There is a special case when <i>n</i> is a
move command: <!-- MATH
 $a\leftarrow c$
 -->
<i>a</i> <img src="compiler_files/img1.png" alt="$ \leftarrow$" align="BOTTOM" border="0" height="10" width="17"> <i>c</i>; in that case we do not add the edge
(<i>a</i>, <i>b</i><sub>k</sub>) if <i>b</i><sub>k</sub> = <i>c</i>. For example, the previous program
has an interference graph with three nodes: <code>a</code>, <code>b</code>, and <code>c</code>,
and two edges: <code>a-c</code> and <code>b-c</code>.

</p><p>
The following is a larger example:
<br><table border="1" cellpadding="3">
<tbody><tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT">x</td>
<td align="LEFT">y</td>
<td align="LEFT">z</td>
<td align="LEFT">w</td>
<td align="LEFT">u</td>
<td align="LEFT">v</td>
</tr>
<tr><td align="LEFT">1.</td>
<td align="LEFT">v := 1</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="LEFT">2.</td>
<td align="LEFT">z := v+1</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT">X</td>
</tr>
<tr><td align="LEFT">3.</td>
<td align="LEFT">x := z * v</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT">X</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT">X</td>
</tr>
<tr><td align="LEFT">4.</td>
<td align="LEFT">y := x * 2</td>
<td align="LEFT">X</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT">X</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="LEFT">5.</td>
<td align="LEFT">w := x+z * y</td>
<td align="LEFT">X</td>
<td align="LEFT">X</td>
<td align="LEFT">X</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="LEFT">6.</td>
<td align="LEFT">u := z+2</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT">X</td>
<td align="LEFT">X</td>
<td align="LEFT">X</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="LEFT">7.</td>
<td align="LEFT">v := u+w+y</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT">X</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT">X</td>
<td align="LEFT">X</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="LEFT">8.</td>
<td align="LEFT">return v * u</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT">X</td>
<td align="LEFT">X</td>
</tr>
</tbody></table>
<br>
For example, <i>v</i> is used in line 3 and the last assignment to <i>v</i> before
this line was in line 1. So <i>v</i> is live on lines 2 and 3.
Also <i>v</i> is used in line 8 and the last assignment to <i>v</i> before
this line was in line 7. So <i>v</i> is also live on line 8.
The interference graph is the following:

</p><p>
<img src="compiler_files/alloc.gif" alt="alloc.gif" align="BOTTOM" border="0" height="160" width="160">

</p><p>

</p><h1><a name="SECTION000130000000000000000">
12 Register Allocation</a>
</h1>

<p>

</p><h2><a name="SECTION000131000000000000000">
12.1 Register Allocation Using the Interference Graph</a>
</h2>

<p>
The interference graph is used for assigning registers to temporary
variables.  If two variables do not interfere (ie, there is no edge
between these two variables in the interference graph) then we can use
the same register for both of them, thus reducing the number of
registers needed. On the other hand, if there is a graph edge between
two variables, then we should not assign the same register to them
since this register needs to hold the values of both variable at one
point of time (because the lives of these variables overlap at one
point of time - this is what interference means).

</p><p>
Suppose that we have <i>n</i> available registers: <!-- MATH
 $r_1,r_2,\ldots,r_n$
 -->
<i>r</i><sub>1</sub>, <i>r</i><sub>2</sub>,..., <i>r</i><sub>n</sub>. If
we view each register as a different color, then the register
allocation problem for the interference graph is equivalent to the
graph coloring problem where we try to assign one of the <i>n</i> different
colors to graph nodes so that no two adjacent nodes have the same
color.  This algorithm is used in map drawing where we have countries
or states on the map and we want to color them using a small fixed
number of colors so that states that have a common border are not
painted with the same color.  The graph in this case has one node for
each state and an edge between two states if they have common borders.

</p><p>
The register allocation algorithm uses a stack of graph nodes to
insert all nodes of the interference graph one at a time.  Each time
it selects a node that has fewer than <i>n</i> neighbors (adjacent nodes).
The idea is that if we can color the graph after we remove this node,
then of course we can color the original graph (with the node
included) because the neighbors of this node can have <i>n</i> - 1 different
colors in the worst case; so we can just assign the available <i>n</i>th
color to the node. This is called <em>simplification</em> of the
graph. Each selected node is pushed in the stack.  Sometimes though we
cannot simplify any further because all nodes have <i>n</i> or more
neighbors. In that case we select one node (ie. variable) to be
spilled into memory instead of assigning a register to it. This is
called <em>spilling</em> and the spilled victim can be selected based on
priorities (eg. which variable is used less frequently, is it outside
a loop, etc). The spilled node is also pushed on the stack.  When the
graph is completely reduced (and all nodes have been pushed in the
stack), we pop the stack one node at a time, we rebuild the
interference graph and at the same time we assign a color to the
popped-out node so that its color is different from the colors of its
neighbors.  This is called the <em>selection</em> phase.  If we can't
assign a color to a node, we spill out the node into memory (a node
selected to be spilled out during the spill phase does not necessarily
mean that it will actually spilled into memory at the end).  If there
are spilled nodes, we use a memory access for each spilled variable
(eg. we use the frame location $fp-24 to store the spilled temporary
variable and we replace all occurrences of this variable in the
program with M[$fp-24]). Then we restart the whole process (the
building of the interference graph, simplification, etc) from the
beginning.  Figures 11.1-11.3 in Section 11.1 in the textbook give an example of this
method.

</p><p>
Consider the following interference graph from the previous section:

</p><p>
<img src="compiler_files/alloc.gif" alt="alloc.gif" align="BOTTOM" border="0" height="160" width="160">

</p><p>
The nodes are pushed in the stack in the order of xvuzyw.
Then, at the selection phase, xyzwuv variables
are assigned the registers <!-- MATH
 $R_0R_2R_1R_0R_1R_0$
 -->
<i>R</i><sub>0</sub><i>R</i><sub>2</sub><i>R</i><sub>1</sub><i>R</i><sub>0</sub><i>R</i><sub>1</sub><i>R</i><sub>0</sub>.

</p><p>
If there is a move instruction in a program (ie. an assignment of the
form <code>a:=b</code>) and there is no conflict between <code>a</code> and
<code>b</code>, then it is a good idea to use the same register for both
<code>a</code> and <code>b</code> so that you can remove the move instruction
entirely from the program. In fact you can just merge the graph nodes
for <code>a</code> and <code>b</code> in the graph into one node. That way nodes
are now labeled by sets of variables, instead of just one variable.
This is called <em>coalescing</em>. This is a good thing to do since it
reduces the number of registers needed and it removes the move
instructions, but it may be bad since it increases the number of
neighbors of the merged nodes, which may lead to an irreducible graph
and a potential spilling. To do this, we add another phase to the
register allocation algorithm, called <em>coalescing</em>, that coalesces
move related nodes.  If we derive an irreducible graph at some point
of time, there is another phase, called <em>freezing</em>, that
de-coalesces one node (into two nodes) and continues the
simplification.

</p><p>
A common criterion for coalescing is that we coalesce two nodes if the
merged node has fewer than <i>n</i> neighbors of degree greater than or
equal to <i>n</i> (where <i>n</i> is the number of available registers). This is
called the Briggs criterion. A slight variation of this is the George
criterion where we coalesce nodes if all the neighbors of one of the
nodes with degree greater than or equal to <i>n</i> already interfere with
the other node.

</p><p>
Coalescing is very useful when handling callee-save registers in a
program. Recall that callee-save registers need to be saved by the
callee procedure to maintain their values upon the exit of the
procedure. Suppose that <code>r3</code> is a callee-save register.  The
procedure needs to save this register into a temporary variable at the
beginning of the procedure (eg. <code>a := r3</code>) and to restore it at
the end of the procedure (ie. <code>r3 := a</code>).  That way, if <code>r3</code>
is not used at all during the procedure body, it will be coalesced
with <code>a</code> and the move instructions will be removed. But
coalescing can happen in many other different situations as long as
there is no interference, which makes this technique very general. Note
that registers in a program are handled as temporary variables with a
preassigned color (precolored nodes). This means that precolored nodes
can only be coalesced with other nodes (they cannot be simplified or
spilled). See the example in Section 11.3 in the textbook for a program with precolored
nodes.

</p><p>

</p><h2><a name="SECTION000132000000000000000">
12.2 Code Generation for Trees</a>
</h2>

<p>
Suppose that you want generate assembly code for complex expression trees
using the fewest number of registers to store intermediate results.
Suppose also that we have two-address instructions of the form
</p><pre>  op   Ri, T
</pre>
where op is an operation (add, sub, mult, etc), Ri is a register (R1,
R2, R3, etc), and T is an address mode such as a memory reference, a
register, indirect access, indexing etc. We also have a move instruction of the form:
<pre>  load   Ri, T
</pre>
For example, for the expression <code>(A-B)+((C+D)+(E*F))</code>, which
corresponds to the AST:
<pre>          +
        /   \
       /      \
      -        +
     / \     /   \
    A   B   +     *
           / \   / \
          C   D E   F
</pre>
we want to generate the following assembly code:
<pre>  load  R2, C
  add   R2, D
  load  R1, E
  mult  R1, F
  add   R2, R1
  load  R1, A
  sub   R1, B
  add   R1, R2
</pre>
That is, we used only two register.

<p>
There is an algorithm that generates code with the least number of
registers.  It is called the <em>Sethi-Ullman</em> algorithm. It consists
of two phases: <em>numbering</em> and <em>code generation</em>. The
numbering phase assigns a number to each tree node that indicates how
many registers are needed to evaluate the subtree of this node.
Suppose that for a tree node <i>T</i>, we need <i>l</i> registers to evaluate
its left subtree and <i>r</i> registers to evaluate its right subtree.
Then if one of these numbers is larger, say <i>l</i> &gt; <i>r</i>, then we can
evaluate the left subtree first and store its result into one of the
registers, say <i>R</i><sub>k</sub>. Now we can evaluate the right subtree using the
same registers we used for the left subtree, except of course <i>R</i><sub>k</sub>
since we want to remember the result of the left subtree. But this is
always possible since <i>l</i> &gt; <i>r</i>. This means that we need <i>l</i> registers to
evaluate <i>T</i> too.  The same happens if <i>r</i> &gt; <i>l</i> but now we need to
evaluate the right subtree first and store the result to a register.
If <i>l</i> = <i>r</i> we need an extra register <i>R</i><sub>l+1</sub> to remember the result of
the left subtree. If <i>T</i> is a tree leaf, then the number of registers
to evaluate <i>T</i> is either 1 or 0 depending whether <i>T</i> is a left or a
right subtree (since an operation such as <code>add R1, A</code> can handle
the right component <code>A</code> directly without storing it into a
register). So the numbering algorithm starts from the tree leaves and
assigns 1 or 0 as explained. Then for each node whose children are
labeled <i>l</i> and <i>r</i>, if <i>l</i> = <i>r</i> then the node number is <i>l</i> + 1 otherwise
it is <i>max</i>(<i>l</i>, <i>r</i>). For example, we have the following numbering for the
previous example:
</p><pre>          2
        /   \
       /      \
      1        2
     / \     /   \
    1   0   1     1
           / \   / \
          1   0 1   0
</pre>
The code generation phase is as follows.  We assume that for each node
<i>T</i> has numbering <i>regs</i>(<i>T</i>).  We use a stack of available registers
which initially contains all the registers in order (with the lower
register at the top).

<p>
<table cellpadding="3">
<tbody><tr><td colspan="3" align="LEFT">generate(<i>T</i>) =</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td colspan="2" align="LEFT">if <i>T</i> is a leaf write ``load top(), <i>T</i>"</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td colspan="2" align="LEFT">if <i>T</i> is an internal node with children <i>l</i> and <i>r</i> then</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td colspan="2" align="LEFT">if <i>regs</i>(<i>r</i>) = 0 then { generate(<i>l</i>); write ``op  top(), <i>r</i>" }</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td colspan="2" align="LEFT">if <!-- MATH
 $regs(l) >= regs(r)$
 -->
<i>regs</i>(<i>l</i> ) &gt; = <i>regs</i>(<i>r</i>)</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">then {</td>
<td align="LEFT">generate(<i>l</i>)</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT"><i>R</i> := pop()</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT">generate(<i>r</i>)</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT">write ``op <i>R</i>, top()"</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT">push(<i>R</i>) }</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td colspan="2" align="LEFT">if <!-- MATH
 $regs(l) < regs(r)$
 -->
<i>regs</i>(<i>l</i> ) &lt; <i>regs</i>(<i>r</i>)</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">then {</td>
<td align="LEFT">swap the top two elements of the stack</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT">generate(<i>r</i>)</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT"><i>R</i> := pop()</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT">generate(<i>l</i>)</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT">write ``op top(), <i>R</i>"</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT">push(<i>R</i>)</td>
</tr>
<tr><td align="LEFT">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
<td align="LEFT">swap the top two elements of the stack }</td>
</tr>
</tbody></table>

</p><p>
This assumes that the number of registers needed is no greater than the
number of available registers. Otherwise, we need to spill the
intermediate result of a node to memory. This algorithm also does not
take advantage of the commutativity and associativity properties of
operators to rearrange the expression tree.

</p><p>

</p><h1><a name="SECTION000140000000000000000">
13 Garbage Collection</a>
</h1>

<p>

</p><h2><a name="SECTION000141000000000000000">
13.1 Storage Allocation</a>
</h2>

<p>
Consider a typical storage organization of a program:

</p><p>
<img src="compiler_files/stack.gif" alt="stack.gif" align="BOTTOM" border="0" height="336" width="210">

</p><p>
All dynamically allocated data are stored in the heap.
These are the data created by <code>malloc</code> in C or <code>new</code> in C++.
You can imagine the heap as a vector of bytes (characters) and <code>end_of_heap</code>
a pointer to the first available byte in the heap:
</p><pre>char heap[heap_size];
int end_of_heap = 0;
</pre>
A trivial implementation of <code>malloc</code> in C is:
<pre>void* malloc ( int size ) {
  void* loc = (void*) &amp;heap[end_of_heap];
  end_of_heap += size;
  return loc;
};
</pre>
If you always create dynamic structures but never delete them,
you will eventually run out of heap space. In that case, <code>malloc</code>
will request the operating system for more heap (this code is not shown). This is very expensive,
because it may require to move the stack data to higher memory locations.
Alternatively, you can recycle the dynamically allocated data that you don't use.
This is done using <code>free</code> in C or <code>delete</code> in C++.
To do so, you need to link all deallocated data in the heap into a list:
<pre>typedef struct Header { struct Header *next; int size; } Header;
Header* free_list;
</pre>
Initially, the free list contains only one element that covers the entire heap
(ie, it's <code>heap_size</code> bytes long):
<pre>void initialize_heap () {
  free_list = (Header*) heap;
  free_list-&gt;next = 0;
  free_list-&gt;size = heap_size;
};
</pre>
(This is terrible C code, but this can only be done by coercing bytes to pointers.)
Note that each cell in the heap has a <code>Header</code> component (ie, a <code>next</code>
pointer and a <code>size</code>) followed by <code>size-sizeof(Header)</code> bytes (so that is <code>size</code> bytes long).
<code>malloc</code> first searches the free list to find a cell large enough to fit the given number of bytes.
If it finds one, it gets a chunk out of the cell leaving the rest untouched:
<pre>void* malloc ( int size ) {
  Header* prev = free_list;
  for(Header* r=free_list; r!=0; prev=r, r=r-&gt;next)
     if (r-&gt;size &gt; size+sizeof(Header))
     {  Header* new_r = (Header*) (((char*) r)+size);
        new_r-&gt;next = r-&gt;next;
        new_r-&gt;size = r-&gt;size;
        if (prev==free_list)
           free_list = new_r;
        else prev-&gt;next = new_r;
        return (void*) r;
     };
  void* loc = (void*) &amp;heap[end_of_heap];
  end_of_heap += size;
  return loc;
};
</pre>
<code>free</code> simply puts the recycled cell at the beginning of the free list:
<pre>void free ( void* x ) {
  if ("size of *x" &lt;= sizeof(Header))
     return;
  ((Header*) x)-&gt;next = free_list;
  ((Header*) x)-&gt;size = "size of *x";
  free_list = (Header*) x;
};
</pre>
We can see that there is a lot of overhead in <code>malloc</code> since the
free list may be very long.  The most important problem though is
fragmentation of the heap into tiny cells, so that even though the
total free space in the free list is plenty, it is useless for large
object allocation.  The reason for fragmentation is that we
unrestrictedly choose a cell from the free list to do allocation.  It
makes more sense to try to find a free cell that provides the requested
number of bytes exactly.  This can be done by maintaining a vector of
free lists, so that the nth element of the vector is a free list that
links all the free cells of size <code>n</code>.

<p>
The above malloc/free way of allocating dynamic cells is called a <em>manual memory allocation</em> since the programmer is responsible for
allocating and deleting objects explicitly.  This is to be contrasted
to the automatic memory management, in which the system manages the
dynamic allocation automatically.  Manual memory management is the
source of the worst and hardest to find bugs. It's also the source of
most of the mysterious program crashes.  It takes the fun out of
programming.  It causes horrible memory problems due to ``overflow",
``fence past errors", ``memory corruption", ``step-on-others-toe"
(hurting other variable's memory locations) or ``memory leaks". The
memory problems are extremely hard to debug and are very time
consuming to fix and troubleshoot. Memory problems bring down the
productivity of programmers. Memory related bugs are very tough to
crack, and even experienced programmers take several days or weeks to
debug memory related problems. Memory bugs may be hidden inside the
code for several months and can cause unexpected program crashes. It
is estimated that the memory bugs due to usage of char* and pointers
in C/C++ is costing $2 billions every year in time lost due to
debugging and downtime of programs.  Now of course all modern
languages (Java, SML, Haskell, etc) use automatic garbage
collection. Despite that, C and C++ are still popular and programmers
spend most of their time trying to do manual memory allocation (and
then, after they remove most core dumps from their program, they port
it to a different architecture and their program crashes!).

</p><p>
Why manual memory management is so hard to do correctly? Basically,
you need to have a global view of how dynamic instances of a type are
created and passed around. This destroys the good software engineering
principle that programs should be developed in small independent
components.  The problem is to keep track of pointer assignments.  If
more than one objects point to a dynamically allocated object, then
the latter object should be deleted only if all objects that point to
it do not need it anymore.  So basically, you need to keep track of
how many pointers are pointing to each object. This is called <em>reference counting</em> and used to be popular for OO languages like C++.
We do not call this method automatic garbage collection because the
programmer again is responsible of putting counters to every object to
count references.  This method is easy to implement for languages like
C++ where you can redefine the assignment operator <code>dest=source</code>,
when both <code>dest</code> and <code>source</code> are pointers to data. 
Instead of using <code>C*</code> for a pointer to an object <code>C</code>,
we use <code>Ref&lt;C&gt;</code>, where the template <code>Ref</code> provides
reference counting to  <code>C</code>:

</p><p>
</p><pre>template&lt; class T &gt;
class Ref {
private:
   int count;
   T* pointer;
   void MayDelete () { if (count==0) delete pointer; };
   void Copy ( const Ref &amp;sp ) {
         ++sp.count;
         count = sp.count;
         pointer = sp.pointer;
   };
public:
   Ref ( T* ptr = 0 ) : count(1), pointer(ptr) {};
   Ref ( const Ref &amp;sp ) { Copy(sp); };
   ~Ref () { MayDelete(); };
   T* operator-&gt; () { return pointer; };
   Ref&amp; operator= ( const Ref &amp;sp ) {
      if (this != &amp;sp) {
         count--;
         MayDelete();
         Copy(sp);
      };
      return *this;
   };
};
</pre>

<p>
When an instance of <code>Ref&lt;C&gt;</code> is created, its counter is set to 1.
When we delete the object, we just decrement the counter because there
may be other objects pointing to it. But when the counter becomes
zero, we delete it.  The only way to move pointers around, is through
an assignment from a <code>C*</code> object to a <code>C*</code> object.  In that
case, the object pointed by the source pointer will have one pointer
more, while the object pointed by the destination pointer will have
one pointer less.  Reference counting avoids some misuses of the heap
but it comes with a high cost: every assignment takes many cycles to
be completed and some of the work may be unnecessary since you may
pass a pointer around causing many unnecessary counter
increments/decrements. In addition, we cannot get rid of cyclic
objects (eg. when A points to B and B points to A) using reference
counting. All objects that participate in a cyclic chain of references
will always have their counters greater than zero, so they will never
be deleted, even if they are garbage.

</p><p>

</p><h2><a name="SECTION000142000000000000000">
13.2 Automatic Garbage Collection</a>
</h2>

<p>
Heap-allocated records that are not reachable by any chain of pointers
from program variables are considered garbage. All other data are
'live'.  This is a very conservative approach but is always safe since
you can never access unreachable data. On the other hand, it may keep
objects that, even though reachable, they will never be accessed by
the program in the future.

</p><p>
With automatic storage management, user programs do not reclaim memory
manually.  When the heap is full, the run-time system suspends the
program and starts garbage collection. When the garbage collection is
done, the user program resumes execution:

</p><p>
</p><pre>char heap[heap_size];
int end_of_heap = 0;
void* malloc ( int size ) {
    if (size+end_of_heap &gt; heap_size)
         GC();            // garbage collection
    void* loc = (void*) &amp;heap[end_of_heap];
    end_of_heap += size;
    return loc;
};
</pre>

<p>

</p><h3><a name="SECTION000142100000000000000">
13.2.1 Mark-and-Sweep Garbage Collection</a>
</h3>

<p>
Here too we use the conservative approximation that if we can reach an
object by following pointers from program variables, then the object
is live (not garbage).  These program variables are called <em>roots</em>
and can be either frame-allocated or static.  Therefore, the garbage
collector needs to check the entire static section as well as all
frames in the run-time stack for pointers to heap.  It is common to
use the following conservative approach: if a word has a value between
the minimum and maximum address of the heap, then it is considered to
be a pointer to the heap.  An object is live if it is pointed by
either a root or by a live object (this is a recursive definition).
The garbage collector needs to start from each root and follow
pointers recursively to mark all live objects.

</p><p>
A Mark-and-Sweep garbage collector has two phases:

</p><ol>
<li>Mark: starting from roots, mark all reachable objects by using a depth-first-search pointer traversal
</li>
<li>Sweep: scan the heap from the beginning to the end and reclaim the unmarked objects (and unmark the marked objects).
</li>
</ol>

<p>
The depth-first-search is done using the function

</p><p>
</p><pre>DFS ( p ) =
{ if *p record is unmarked
     then mark *p
  for each pointer p-&gt;fi of the record *p do DFS(p-&gt;fi)
}
</pre>

<p>
which is called from every root:

</p><p>
</p><pre>for each p in roots
   DFS(p)
</pre>

<p>
The mark phase is:

</p><p>
</p><pre>p = 'first object in the heap'
while p is in the heap do
{  if *p is marked
      then unmark *p
   else insert *p into the free list
   p = p+(size of record *p)
}
</pre>

<p>
For example, consider the following objects in memory at the time the
garbage collector takes over:

</p><p>
<img src="compiler_files/gc.gif" alt="gc.gif" align="BOTTOM" border="0" height="262" width="290">

</p><p>
The roots can be static or frame-allocated variables.  Let's assume
that these objects are represented as follows in memory (as
consecutive bytes):

</p><p>
<table border="1" cellpadding="3">
<tbody><tr><td align="RIGHT">1</td>
<td align="CENTER">6</td>
<td align="CENTER">e</td>
<td align="CENTER">3</td>
</tr>
<tr><td align="RIGHT">2</td>
<td align="CENTER">0</td>
<td align="CENTER">i</td>
<td align="CENTER">4</td>
</tr>
<tr><td align="RIGHT">3</td>
<td align="CENTER">0</td>
<td align="CENTER">d</td>
<td align="CENTER">5</td>
</tr>
<tr><td align="RIGHT">4</td>
<td align="CENTER">0</td>
<td align="CENTER">g</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">5</td>
<td align="CENTER">0</td>
<td align="CENTER">a</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">6</td>
<td align="CENTER">8</td>
<td align="CENTER">b</td>
<td align="CENTER">7</td>
</tr>
<tr><td align="RIGHT">7</td>
<td align="CENTER">10</td>
<td align="CENTER">k</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">8</td>
<td align="CENTER">0</td>
<td align="CENTER">c</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">9</td>
<td align="CENTER">0</td>
<td align="CENTER">j</td>
<td align="CENTER">10</td>
</tr>
<tr><td align="RIGHT">10</td>
<td align="CENTER">0</td>
<td align="CENTER">f</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">11</td>
<td align="CENTER">0</td>
<td align="CENTER">h</td>
<td align="CENTER">12</td>
</tr>
<tr><td align="RIGHT">12</td>
<td align="CENTER">11</td>
<td align="CENTER">l</td>
<td align="CENTER">0</td>
</tr>
</tbody></table>
<br>
<br>
Here, 0 are null pointers while the other pointers are memory addresses.
That is, the free list is 0 (empty) and the roots are 1, 6, and 9.

</p><p>
After the mark-and-sweep garbage collection, the memory layout becomes:

</p><p>
<table border="1" cellpadding="3">
<tbody><tr><td align="RIGHT">1</td>
<td align="CENTER">6</td>
<td align="CENTER">e</td>
<td align="CENTER">3</td>
</tr>
<tr><td align="RIGHT">2</td>
<td align="CENTER">0</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
</tr>
<tr><td align="RIGHT">3</td>
<td align="CENTER">0</td>
<td align="CENTER">d</td>
<td align="CENTER">5</td>
</tr>
<tr><td align="RIGHT">4</td>
<td align="CENTER">2</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
</tr>
<tr><td align="RIGHT">5</td>
<td align="CENTER">0</td>
<td align="CENTER">a</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">6</td>
<td align="CENTER">8</td>
<td align="CENTER">b</td>
<td align="CENTER">7</td>
</tr>
<tr><td align="RIGHT">7</td>
<td align="CENTER">10</td>
<td align="CENTER">k</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">8</td>
<td align="CENTER">0</td>
<td align="CENTER">c</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">9</td>
<td align="CENTER">0</td>
<td align="CENTER">j</td>
<td align="CENTER">10</td>
</tr>
<tr><td align="RIGHT">10</td>
<td align="CENTER">0</td>
<td align="CENTER">f</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">11</td>
<td align="CENTER">4</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
</tr>
<tr><td align="RIGHT">12</td>
<td align="CENTER">11</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
</tr>
</tbody></table>
where the free list points to the cell 12 now.

</p><p>

</p><h3><a name="SECTION000142200000000000000">
13.2.2 Copying Garbage Collection</a>
</h3>

<p>
A copying garbage collector uses two heaps:

</p><ol>
<li>from-space: the current working heap
</li>
<li>to-space: needs to be in memory during garbage collection only
</li>
</ol>
At garbage collection time, the garbage collector creates an empty
to-space heap in memory (of the same size as the from-space), copies
the live objects from the from-space to the to-space (making sure that
pointers are referring to the to-space), disposes the from-space, and
finally uses the to-space as the new from-space.

<p>
Converting a pointer <code>p</code> that points to a from-space into a
pointer that points to the to-space space, is called <em>forwarding a
pointer</em>:

</p><p>
</p><pre>forward (p) {
   if p points t from-space
      then if p.f1 points to to-space
                 then return p.f1
      else for each field fi of p
                    next.fi := p.fi
             p.f1 := next
             next := next + (size of *p)
             return p.f1
   else return p
</pre>

<p>
Forwarding pointers can be done in breadth-first-search, using
Cheney's Algorithm. Compared to depth-first-search,
breadth-first-search has better locality of reference:

</p><p>
</p><pre>scan := begin-of-to-space
next := scan
for each root r
    r := forward(r)
while scan &lt; next
    for each field fi of *scan
           scan.fi := forward(scan.fi)
    scan := scan + (size of *scan)
</pre>

<p>
Cheney's Algorithm uses a very simple allocation algorithm and has no
need for stack (since is not recursive).  More importantly, its run
time depends on the number of live objects, not on the heap size.
Furthermore, it does not suffer from data fragmentation, resulting
into a more compact memory.  In addition, it allows incremental
(concurrent) garbage collection.  On the other hand, it needs double
the amount of memory and needs to recognize all pointers to heap.

</p><p>
For example,

</p><p>
<table width="43">
<tbody><tr><td>
roots
<br>
<br>
<br><table border="1" cellpadding="3">
<tbody><tr><td align="CENTER">1</td>
</tr>
<tr><td align="CENTER">6</td>
</tr>
<tr><td align="CENTER">9</td>
</tr>
</tbody></table></td></tr>
</tbody></table>
<table width="173">
<tbody><tr><td>
<table border="1" cellpadding="3">
<tbody><tr><td align="RIGHT">1</td>
<td align="CENTER">1</td>
<td align="CENTER">6</td>
<td align="CENTER">e</td>
<td align="CENTER">3</td>
</tr>
<tr><td align="RIGHT">2</td>
<td align="CENTER">2</td>
<td align="CENTER">0</td>
<td align="CENTER">i</td>
<td align="CENTER">4</td>
</tr>
<tr><td align="RIGHT">3</td>
<td align="CENTER">3</td>
<td align="CENTER">0</td>
<td align="CENTER">d</td>
<td align="CENTER">5</td>
</tr>
<tr><td align="RIGHT">4</td>
<td align="CENTER">4</td>
<td align="CENTER">0</td>
<td align="CENTER">g</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">5</td>
<td align="CENTER">5</td>
<td align="CENTER">0</td>
<td align="CENTER">a</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">6</td>
<td align="CENTER">6</td>
<td align="CENTER">8</td>
<td align="CENTER">b</td>
<td align="CENTER">7</td>
</tr>
<tr><td align="RIGHT">7</td>
<td align="CENTER">7</td>
<td align="CENTER">10</td>
<td align="CENTER">k</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">8</td>
<td align="CENTER">8</td>
<td align="CENTER">0</td>
<td align="CENTER">c</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">9</td>
<td align="CENTER">9</td>
<td align="CENTER">0</td>
<td align="CENTER">j</td>
<td align="CENTER">10</td>
</tr>
<tr><td align="RIGHT">10</td>
<td align="CENTER">10</td>
<td align="CENTER">0</td>
<td align="CENTER">f</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">11</td>
<td align="CENTER">11</td>
<td align="CENTER">0</td>
<td align="CENTER">h</td>
<td align="CENTER">12</td>
</tr>
<tr><td align="RIGHT">12</td>
<td align="CENTER">12</td>
<td align="CENTER">11</td>
<td align="CENTER">l</td>
<td align="CENTER">0</td>
</tr>
</tbody></table>
<br>
<br><font size="+2"><b>from-space</b></font>
</td></tr>
</tbody></table>
<table width="173">
<tbody><tr><td>
<table border="1" cellpadding="3">
<tbody><tr><td align="RIGHT">51</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT"><!-- MATH
 $\leftarrow$
 -->
<img src="compiler_files/img1.png" alt="$ \leftarrow$" align="BOTTOM" border="0" height="10" width="17"> scan, next</td>
</tr>
<tr><td align="RIGHT">52</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">53</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">54</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">55</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">56</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">57</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">58</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">59</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">60</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">61</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">62</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
</tbody></table>
<br>
<br><font size="+2"><b>to-space</b></font>
</td></tr>
</tbody></table>
<br>
<br>
After we forward the roots from the from-space to the to-space,
the to-space will contain the forwarded roots, and
the roots and the forward pointers of the root elements in the from-space 
will point to the to-space, as shown below:
<br>
<br><table width="43">
<tbody><tr><td>
roots
<br>
<br>
<br><table border="1" cellpadding="3">
<tbody><tr><td align="CENTER">51</td>
</tr>
<tr><td align="CENTER">52</td>
</tr>
<tr><td align="CENTER">53</td>
</tr>
</tbody></table></td></tr>
</tbody></table>
<table width="173">
<tbody><tr><td>
<table border="1" cellpadding="3">
<tbody><tr><td align="RIGHT">1</td>
<td align="CENTER">51</td>
<td align="CENTER">6</td>
<td align="CENTER">e</td>
<td align="CENTER">3</td>
</tr>
<tr><td align="RIGHT">2</td>
<td align="CENTER">2</td>
<td align="CENTER">0</td>
<td align="CENTER">i</td>
<td align="CENTER">4</td>
</tr>
<tr><td align="RIGHT">3</td>
<td align="CENTER">3</td>
<td align="CENTER">0</td>
<td align="CENTER">d</td>
<td align="CENTER">5</td>
</tr>
<tr><td align="RIGHT">4</td>
<td align="CENTER">4</td>
<td align="CENTER">0</td>
<td align="CENTER">g</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">5</td>
<td align="CENTER">5</td>
<td align="CENTER">0</td>
<td align="CENTER">a</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">6</td>
<td align="CENTER">52</td>
<td align="CENTER">8</td>
<td align="CENTER">b</td>
<td align="CENTER">7</td>
</tr>
<tr><td align="RIGHT">7</td>
<td align="CENTER">7</td>
<td align="CENTER">10</td>
<td align="CENTER">k</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">8</td>
<td align="CENTER">8</td>
<td align="CENTER">0</td>
<td align="CENTER">c</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">9</td>
<td align="CENTER">53</td>
<td align="CENTER">0</td>
<td align="CENTER">j</td>
<td align="CENTER">10</td>
</tr>
<tr><td align="RIGHT">10</td>
<td align="CENTER">10</td>
<td align="CENTER">0</td>
<td align="CENTER">f</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">11</td>
<td align="CENTER">11</td>
<td align="CENTER">0</td>
<td align="CENTER">h</td>
<td align="CENTER">12</td>
</tr>
<tr><td align="RIGHT">12</td>
<td align="CENTER">12</td>
<td align="CENTER">11</td>
<td align="CENTER">l</td>
<td align="CENTER">0</td>
</tr>
</tbody></table>
<br>
<br><font size="+2"><b>from-space</b></font>
</td></tr>
</tbody></table>
<table width="173">
<tbody><tr><td>
<table border="1" cellpadding="3">
<tbody><tr><td align="RIGHT">51</td>
<td align="CENTER">51</td>
<td align="CENTER">6</td>
<td align="CENTER">e</td>
<td align="CENTER">3</td>
<td align="LEFT"><!-- MATH
 $\leftarrow$
 -->
<img src="compiler_files/img1.png" alt="$ \leftarrow$" align="BOTTOM" border="0" height="10" width="17"> scan</td>
</tr>
<tr><td align="RIGHT">52</td>
<td align="CENTER">52</td>
<td align="CENTER">8</td>
<td align="CENTER">b</td>
<td align="CENTER">7</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">53</td>
<td align="CENTER">53</td>
<td align="CENTER">0</td>
<td align="CENTER">j</td>
<td align="CENTER">10</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">54</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT"><!-- MATH
 $\leftarrow$
 -->
<img src="compiler_files/img1.png" alt="$ \leftarrow$" align="BOTTOM" border="0" height="10" width="17"> next</td>
</tr>
<tr><td align="RIGHT">55</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">56</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">57</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">58</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">59</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">60</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">61</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">62</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
</tbody></table>
<br>
<br><font size="+2"><b>to-space</b></font>
</td></tr>
</tbody></table>
<br>
<br>
Then, we forward the pointers of the first element of the to-space pointed by the scan pointer (element 51).
The first pointer 6 has already been forwarded to 52, as we can see from the element 6 in the from-space.
The second pointer 3 is forwarded at the end of the to-space to 54:
<br>
<br><table width="43">
<tbody><tr><td>
roots
<br>
<br>
<br><table border="1" cellpadding="3">
<tbody><tr><td align="CENTER">51</td>
</tr>
<tr><td align="CENTER">52</td>
</tr>
<tr><td align="CENTER">53</td>
</tr>
</tbody></table></td></tr>
</tbody></table>
<table width="173">
<tbody><tr><td>
<table border="1" cellpadding="3">
<tbody><tr><td align="RIGHT">1</td>
<td align="CENTER">51</td>
<td align="CENTER">6</td>
<td align="CENTER">e</td>
<td align="CENTER">3</td>
</tr>
<tr><td align="RIGHT">2</td>
<td align="CENTER">2</td>
<td align="CENTER">0</td>
<td align="CENTER">i</td>
<td align="CENTER">4</td>
</tr>
<tr><td align="RIGHT">3</td>
<td align="CENTER">54</td>
<td align="CENTER">0</td>
<td align="CENTER">d</td>
<td align="CENTER">5</td>
</tr>
<tr><td align="RIGHT">4</td>
<td align="CENTER">4</td>
<td align="CENTER">0</td>
<td align="CENTER">g</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">5</td>
<td align="CENTER">5</td>
<td align="CENTER">0</td>
<td align="CENTER">a</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">6</td>
<td align="CENTER">52</td>
<td align="CENTER">8</td>
<td align="CENTER">b</td>
<td align="CENTER">7</td>
</tr>
<tr><td align="RIGHT">7</td>
<td align="CENTER">7</td>
<td align="CENTER">10</td>
<td align="CENTER">k</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">8</td>
<td align="CENTER">8</td>
<td align="CENTER">0</td>
<td align="CENTER">c</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">9</td>
<td align="CENTER">53</td>
<td align="CENTER">0</td>
<td align="CENTER">j</td>
<td align="CENTER">10</td>
</tr>
<tr><td align="RIGHT">10</td>
<td align="CENTER">10</td>
<td align="CENTER">0</td>
<td align="CENTER">f</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">11</td>
<td align="CENTER">11</td>
<td align="CENTER">0</td>
<td align="CENTER">h</td>
<td align="CENTER">12</td>
</tr>
<tr><td align="RIGHT">12</td>
<td align="CENTER">12</td>
<td align="CENTER">11</td>
<td align="CENTER">l</td>
<td align="CENTER">0</td>
</tr>
</tbody></table>
<br>
<br><font size="+2"><b>from-space</b></font>
</td></tr>
</tbody></table>
<table width="173">
<tbody><tr><td>
<table border="1" cellpadding="3">
<tbody><tr><td align="RIGHT">51</td>
<td align="CENTER">51</td>
<td align="CENTER">52</td>
<td align="CENTER">e</td>
<td align="CENTER">54</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">52</td>
<td align="CENTER">52</td>
<td align="CENTER">8</td>
<td align="CENTER">b</td>
<td align="CENTER">7</td>
<td align="LEFT"><!-- MATH
 $\leftarrow$
 -->
<img src="compiler_files/img1.png" alt="$ \leftarrow$" align="BOTTOM" border="0" height="10" width="17"> scan</td>
</tr>
<tr><td align="RIGHT">53</td>
<td align="CENTER">53</td>
<td align="CENTER">0</td>
<td align="CENTER">j</td>
<td align="CENTER">10</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">54</td>
<td align="CENTER">54</td>
<td align="CENTER">0</td>
<td align="CENTER">d</td>
<td align="CENTER">5</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">55</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT"><!-- MATH
 $\leftarrow$
 -->
<img src="compiler_files/img1.png" alt="$ \leftarrow$" align="BOTTOM" border="0" height="10" width="17"> next</td>
</tr>
<tr><td align="RIGHT">56</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">57</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">58</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">59</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">60</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">61</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">62</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
</tbody></table>
<br>
<br><font size="+2"><b>to-space</b></font>
</td></tr>
</tbody></table>
<br>
<br>
Now we forward the pointer 8 of element 52:
<br>
<br><table width="43">
<tbody><tr><td>
roots
<br>
<br>
<br><table border="1" cellpadding="3">
<tbody><tr><td align="CENTER">51</td>
</tr>
<tr><td align="CENTER">52</td>
</tr>
<tr><td align="CENTER">53</td>
</tr>
</tbody></table></td></tr>
</tbody></table>
<table width="173">
<tbody><tr><td>
<table border="1" cellpadding="3">
<tbody><tr><td align="RIGHT">1</td>
<td align="CENTER">51</td>
<td align="CENTER">6</td>
<td align="CENTER">e</td>
<td align="CENTER">3</td>
</tr>
<tr><td align="RIGHT">2</td>
<td align="CENTER">2</td>
<td align="CENTER">0</td>
<td align="CENTER">i</td>
<td align="CENTER">4</td>
</tr>
<tr><td align="RIGHT">3</td>
<td align="CENTER">54</td>
<td align="CENTER">0</td>
<td align="CENTER">d</td>
<td align="CENTER">5</td>
</tr>
<tr><td align="RIGHT">4</td>
<td align="CENTER">4</td>
<td align="CENTER">0</td>
<td align="CENTER">g</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">5</td>
<td align="CENTER">5</td>
<td align="CENTER">0</td>
<td align="CENTER">a</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">6</td>
<td align="CENTER">52</td>
<td align="CENTER">8</td>
<td align="CENTER">b</td>
<td align="CENTER">7</td>
</tr>
<tr><td align="RIGHT">7</td>
<td align="CENTER">7</td>
<td align="CENTER">10</td>
<td align="CENTER">k</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">8</td>
<td align="CENTER">55</td>
<td align="CENTER">0</td>
<td align="CENTER">c</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">9</td>
<td align="CENTER">53</td>
<td align="CENTER">0</td>
<td align="CENTER">j</td>
<td align="CENTER">10</td>
</tr>
<tr><td align="RIGHT">10</td>
<td align="CENTER">10</td>
<td align="CENTER">0</td>
<td align="CENTER">f</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">11</td>
<td align="CENTER">11</td>
<td align="CENTER">0</td>
<td align="CENTER">h</td>
<td align="CENTER">12</td>
</tr>
<tr><td align="RIGHT">12</td>
<td align="CENTER">12</td>
<td align="CENTER">11</td>
<td align="CENTER">l</td>
<td align="CENTER">0</td>
</tr>
</tbody></table>
<br>
<br><font size="+2"><b>from-space</b></font>
</td></tr>
</tbody></table>
<table width="173">
<tbody><tr><td>
<table border="1" cellpadding="3">
<tbody><tr><td align="RIGHT">51</td>
<td align="CENTER">51</td>
<td align="CENTER">52</td>
<td align="CENTER">e</td>
<td align="CENTER">54</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">52</td>
<td align="CENTER">52</td>
<td align="CENTER">55</td>
<td align="CENTER">b</td>
<td align="CENTER">7</td>
<td align="LEFT"><!-- MATH
 $\leftarrow$
 -->
<img src="compiler_files/img1.png" alt="$ \leftarrow$" align="BOTTOM" border="0" height="10" width="17"> scan</td>
</tr>
<tr><td align="RIGHT">53</td>
<td align="CENTER">53</td>
<td align="CENTER">0</td>
<td align="CENTER">j</td>
<td align="CENTER">10</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">54</td>
<td align="CENTER">54</td>
<td align="CENTER">0</td>
<td align="CENTER">d</td>
<td align="CENTER">5</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">55</td>
<td align="CENTER">55</td>
<td align="CENTER">0</td>
<td align="CENTER">c</td>
<td align="CENTER">0</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">56</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT"><!-- MATH
 $\leftarrow$
 -->
<img src="compiler_files/img1.png" alt="$ \leftarrow$" align="BOTTOM" border="0" height="10" width="17"> next</td>
</tr>
<tr><td align="RIGHT">57</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">58</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">59</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">60</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">61</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">62</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
</tbody></table>
<br>
<br><font size="+2"><b>to-space</b></font>
</td></tr>
</tbody></table>
<br>
<br>
and the pointer 7 of element 52:
<br>
<br><table width="43">
<tbody><tr><td>
roots
<br>
<br>
<br><table border="1" cellpadding="3">
<tbody><tr><td align="CENTER">51</td>
</tr>
<tr><td align="CENTER">52</td>
</tr>
<tr><td align="CENTER">53</td>
</tr>
</tbody></table></td></tr>
</tbody></table>
<table width="173">
<tbody><tr><td>
<table border="1" cellpadding="3">
<tbody><tr><td align="RIGHT">1</td>
<td align="CENTER">51</td>
<td align="CENTER">6</td>
<td align="CENTER">e</td>
<td align="CENTER">3</td>
</tr>
<tr><td align="RIGHT">2</td>
<td align="CENTER">2</td>
<td align="CENTER">0</td>
<td align="CENTER">i</td>
<td align="CENTER">4</td>
</tr>
<tr><td align="RIGHT">3</td>
<td align="CENTER">54</td>
<td align="CENTER">0</td>
<td align="CENTER">d</td>
<td align="CENTER">5</td>
</tr>
<tr><td align="RIGHT">4</td>
<td align="CENTER">4</td>
<td align="CENTER">0</td>
<td align="CENTER">g</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">5</td>
<td align="CENTER">5</td>
<td align="CENTER">0</td>
<td align="CENTER">a</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">6</td>
<td align="CENTER">52</td>
<td align="CENTER">8</td>
<td align="CENTER">b</td>
<td align="CENTER">7</td>
</tr>
<tr><td align="RIGHT">7</td>
<td align="CENTER">56</td>
<td align="CENTER">10</td>
<td align="CENTER">k</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">8</td>
<td align="CENTER">55</td>
<td align="CENTER">0</td>
<td align="CENTER">c</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">9</td>
<td align="CENTER">53</td>
<td align="CENTER">0</td>
<td align="CENTER">j</td>
<td align="CENTER">10</td>
</tr>
<tr><td align="RIGHT">10</td>
<td align="CENTER">10</td>
<td align="CENTER">0</td>
<td align="CENTER">f</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">11</td>
<td align="CENTER">11</td>
<td align="CENTER">0</td>
<td align="CENTER">h</td>
<td align="CENTER">12</td>
</tr>
<tr><td align="RIGHT">12</td>
<td align="CENTER">12</td>
<td align="CENTER">11</td>
<td align="CENTER">l</td>
<td align="CENTER">0</td>
</tr>
</tbody></table>
<br>
<br><font size="+2"><b>from-space</b></font>
</td></tr>
</tbody></table>
<table width="173">
<tbody><tr><td>
<table border="1" cellpadding="3">
<tbody><tr><td align="RIGHT">51</td>
<td align="CENTER">51</td>
<td align="CENTER">52</td>
<td align="CENTER">e</td>
<td align="CENTER">54</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">52</td>
<td align="CENTER">52</td>
<td align="CENTER">55</td>
<td align="CENTER">b</td>
<td align="CENTER">56</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">53</td>
<td align="CENTER">53</td>
<td align="CENTER">0</td>
<td align="CENTER">j</td>
<td align="CENTER">10</td>
<td align="LEFT"><!-- MATH
 $\leftarrow$
 -->
<img src="compiler_files/img1.png" alt="$ \leftarrow$" align="BOTTOM" border="0" height="10" width="17"> scan</td>
</tr>
<tr><td align="RIGHT">54</td>
<td align="CENTER">54</td>
<td align="CENTER">0</td>
<td align="CENTER">d</td>
<td align="CENTER">5</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">55</td>
<td align="CENTER">55</td>
<td align="CENTER">0</td>
<td align="CENTER">c</td>
<td align="CENTER">0</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">56</td>
<td align="CENTER">56</td>
<td align="CENTER">10</td>
<td align="CENTER">k</td>
<td align="CENTER">0</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">57</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT"><!-- MATH
 $\leftarrow$
 -->
<img src="compiler_files/img1.png" alt="$ \leftarrow$" align="BOTTOM" border="0" height="10" width="17"> next</td>
</tr>
<tr><td align="RIGHT">58</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">59</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">60</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">61</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">62</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
</tbody></table>
<br>
<br>
<br><font size="+2"><b>to-space</b></font>
</td></tr>
</tbody></table>
<br>
<br>
Now we forward the pointer 10 of element 53:
<br>
<br><table width="43">
<tbody><tr><td>
roots
<br>
<br>
<br><table border="1" cellpadding="3">
<tbody><tr><td align="CENTER">51</td>
</tr>
<tr><td align="CENTER">52</td>
</tr>
<tr><td align="CENTER">53</td>
</tr>
</tbody></table></td></tr>
</tbody></table>
<table width="173">
<tbody><tr><td>
<table border="1" cellpadding="3">
<tbody><tr><td align="RIGHT">1</td>
<td align="CENTER">51</td>
<td align="CENTER">6</td>
<td align="CENTER">e</td>
<td align="CENTER">3</td>
</tr>
<tr><td align="RIGHT">2</td>
<td align="CENTER">2</td>
<td align="CENTER">0</td>
<td align="CENTER">i</td>
<td align="CENTER">4</td>
</tr>
<tr><td align="RIGHT">3</td>
<td align="CENTER">54</td>
<td align="CENTER">0</td>
<td align="CENTER">d</td>
<td align="CENTER">5</td>
</tr>
<tr><td align="RIGHT">4</td>
<td align="CENTER">4</td>
<td align="CENTER">0</td>
<td align="CENTER">g</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">5</td>
<td align="CENTER">5</td>
<td align="CENTER">0</td>
<td align="CENTER">a</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">6</td>
<td align="CENTER">52</td>
<td align="CENTER">8</td>
<td align="CENTER">b</td>
<td align="CENTER">7</td>
</tr>
<tr><td align="RIGHT">7</td>
<td align="CENTER">56</td>
<td align="CENTER">10</td>
<td align="CENTER">k</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">8</td>
<td align="CENTER">55</td>
<td align="CENTER">0</td>
<td align="CENTER">c</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">9</td>
<td align="CENTER">53</td>
<td align="CENTER">0</td>
<td align="CENTER">j</td>
<td align="CENTER">10</td>
</tr>
<tr><td align="RIGHT">10</td>
<td align="CENTER">57</td>
<td align="CENTER">0</td>
<td align="CENTER">f</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">11</td>
<td align="CENTER">11</td>
<td align="CENTER">0</td>
<td align="CENTER">h</td>
<td align="CENTER">12</td>
</tr>
<tr><td align="RIGHT">12</td>
<td align="CENTER">12</td>
<td align="CENTER">11</td>
<td align="CENTER">l</td>
<td align="CENTER">0</td>
</tr>
</tbody></table>
<br>
<br><font size="+2"><b>from-space</b></font>
</td></tr>
</tbody></table>
<table width="173">
<tbody><tr><td>
<table border="1" cellpadding="3">
<tbody><tr><td align="RIGHT">51</td>
<td align="CENTER">51</td>
<td align="CENTER">52</td>
<td align="CENTER">e</td>
<td align="CENTER">54</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">52</td>
<td align="CENTER">52</td>
<td align="CENTER">55</td>
<td align="CENTER">b</td>
<td align="CENTER">56</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">53</td>
<td align="CENTER">53</td>
<td align="CENTER">0</td>
<td align="CENTER">j</td>
<td align="CENTER">57</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">54</td>
<td align="CENTER">54</td>
<td align="CENTER">0</td>
<td align="CENTER">d</td>
<td align="CENTER">5</td>
<td align="LEFT"><!-- MATH
 $\leftarrow$
 -->
<img src="compiler_files/img1.png" alt="$ \leftarrow$" align="BOTTOM" border="0" height="10" width="17"> scan</td>
</tr>
<tr><td align="RIGHT">55</td>
<td align="CENTER">55</td>
<td align="CENTER">0</td>
<td align="CENTER">c</td>
<td align="CENTER">0</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">56</td>
<td align="CENTER">56</td>
<td align="CENTER">10</td>
<td align="CENTER">k</td>
<td align="CENTER">0</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">57</td>
<td align="CENTER">57</td>
<td align="CENTER">0</td>
<td align="CENTER">f</td>
<td align="CENTER">0</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">58</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT"><!-- MATH
 $\leftarrow$
 -->
<img src="compiler_files/img1.png" alt="$ \leftarrow$" align="BOTTOM" border="0" height="10" width="17"> next</td>
</tr>
<tr><td align="RIGHT">59</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">60</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">61</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">62</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
</tbody></table>
<br>
<br><font size="+2"><b>to-space</b></font>
</td></tr>
</tbody></table>
<br>
<br>
Then we forward the pointer 5 of element 54:
<br>
<br><table width="43">
<tbody><tr><td>
roots
<br>
<br>
<br><table border="1" cellpadding="3">
<tbody><tr><td align="CENTER">51</td>
</tr>
<tr><td align="CENTER">52</td>
</tr>
<tr><td align="CENTER">53</td>
</tr>
</tbody></table></td></tr>
</tbody></table>
<table width="173">
<tbody><tr><td>
<table border="1" cellpadding="3">
<tbody><tr><td align="RIGHT">1</td>
<td align="CENTER">51</td>
<td align="CENTER">6</td>
<td align="CENTER">e</td>
<td align="CENTER">3</td>
</tr>
<tr><td align="RIGHT">2</td>
<td align="CENTER">2</td>
<td align="CENTER">0</td>
<td align="CENTER">i</td>
<td align="CENTER">4</td>
</tr>
<tr><td align="RIGHT">3</td>
<td align="CENTER">54</td>
<td align="CENTER">0</td>
<td align="CENTER">d</td>
<td align="CENTER">5</td>
</tr>
<tr><td align="RIGHT">4</td>
<td align="CENTER">4</td>
<td align="CENTER">0</td>
<td align="CENTER">g</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">5</td>
<td align="CENTER">58</td>
<td align="CENTER">0</td>
<td align="CENTER">a</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">6</td>
<td align="CENTER">52</td>
<td align="CENTER">8</td>
<td align="CENTER">b</td>
<td align="CENTER">7</td>
</tr>
<tr><td align="RIGHT">7</td>
<td align="CENTER">56</td>
<td align="CENTER">10</td>
<td align="CENTER">k</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">8</td>
<td align="CENTER">55</td>
<td align="CENTER">0</td>
<td align="CENTER">c</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">9</td>
<td align="CENTER">53</td>
<td align="CENTER">0</td>
<td align="CENTER">j</td>
<td align="CENTER">10</td>
</tr>
<tr><td align="RIGHT">10</td>
<td align="CENTER">57</td>
<td align="CENTER">0</td>
<td align="CENTER">f</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">11</td>
<td align="CENTER">11</td>
<td align="CENTER">0</td>
<td align="CENTER">h</td>
<td align="CENTER">12</td>
</tr>
<tr><td align="RIGHT">12</td>
<td align="CENTER">12</td>
<td align="CENTER">11</td>
<td align="CENTER">l</td>
<td align="CENTER">0</td>
</tr>
</tbody></table>
<br>
<br><font size="+2"><b>from-space</b></font>
</td></tr>
</tbody></table>
<table width="173">
<tbody><tr><td>
<table border="1" cellpadding="3">
<tbody><tr><td align="RIGHT">51</td>
<td align="CENTER">51</td>
<td align="CENTER">52</td>
<td align="CENTER">e</td>
<td align="CENTER">54</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">52</td>
<td align="CENTER">52</td>
<td align="CENTER">55</td>
<td align="CENTER">b</td>
<td align="CENTER">56</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">53</td>
<td align="CENTER">53</td>
<td align="CENTER">0</td>
<td align="CENTER">j</td>
<td align="CENTER">57</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">54</td>
<td align="CENTER">54</td>
<td align="CENTER">0</td>
<td align="CENTER">d</td>
<td align="CENTER">58</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">55</td>
<td align="CENTER">55</td>
<td align="CENTER">0</td>
<td align="CENTER">c</td>
<td align="CENTER">0</td>
<td align="LEFT"><!-- MATH
 $\leftarrow$
 -->
<img src="compiler_files/img1.png" alt="$ \leftarrow$" align="BOTTOM" border="0" height="10" width="17"> scan</td>
</tr>
<tr><td align="RIGHT">56</td>
<td align="CENTER">56</td>
<td align="CENTER">10</td>
<td align="CENTER">k</td>
<td align="CENTER">0</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">57</td>
<td align="CENTER">57</td>
<td align="CENTER">0</td>
<td align="CENTER">f</td>
<td align="CENTER">0</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">58</td>
<td align="CENTER">58</td>
<td align="CENTER">0</td>
<td align="CENTER">a</td>
<td align="CENTER">0</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">59</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT"><!-- MATH
 $\leftarrow$
 -->
<img src="compiler_files/img1.png" alt="$ \leftarrow$" align="BOTTOM" border="0" height="10" width="17"> next</td>
</tr>
<tr><td align="RIGHT">60</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">61</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">62</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
</tbody></table>
<br>
<br><font size="+2"><b>to-space</b></font>
</td></tr>
</tbody></table>
<br>
<br>
The pointer 10 of element 56 has already been forwarded.
Therefore, we get:
<br>
<br><table width="43">
<tbody><tr><td>
roots
<br>
<br>
<br><table border="1" cellpadding="3">
<tbody><tr><td align="CENTER">51</td>
</tr>
<tr><td align="CENTER">52</td>
</tr>
<tr><td align="CENTER">53</td>
</tr>
</tbody></table></td></tr>
</tbody></table>
<table width="173">
<tbody><tr><td>
<table border="1" cellpadding="3">
<tbody><tr><td align="RIGHT">1</td>
<td align="CENTER">51</td>
<td align="CENTER">6</td>
<td align="CENTER">e</td>
<td align="CENTER">3</td>
</tr>
<tr><td align="RIGHT">2</td>
<td align="CENTER">2</td>
<td align="CENTER">0</td>
<td align="CENTER">i</td>
<td align="CENTER">4</td>
</tr>
<tr><td align="RIGHT">3</td>
<td align="CENTER">54</td>
<td align="CENTER">0</td>
<td align="CENTER">d</td>
<td align="CENTER">5</td>
</tr>
<tr><td align="RIGHT">4</td>
<td align="CENTER">4</td>
<td align="CENTER">0</td>
<td align="CENTER">g</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">5</td>
<td align="CENTER">58</td>
<td align="CENTER">0</td>
<td align="CENTER">a</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">6</td>
<td align="CENTER">52</td>
<td align="CENTER">8</td>
<td align="CENTER">b</td>
<td align="CENTER">7</td>
</tr>
<tr><td align="RIGHT">7</td>
<td align="CENTER">56</td>
<td align="CENTER">10</td>
<td align="CENTER">k</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">8</td>
<td align="CENTER">55</td>
<td align="CENTER">0</td>
<td align="CENTER">c</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">9</td>
<td align="CENTER">53</td>
<td align="CENTER">0</td>
<td align="CENTER">j</td>
<td align="CENTER">10</td>
</tr>
<tr><td align="RIGHT">10</td>
<td align="CENTER">57</td>
<td align="CENTER">0</td>
<td align="CENTER">f</td>
<td align="CENTER">0</td>
</tr>
<tr><td align="RIGHT">11</td>
<td align="CENTER">11</td>
<td align="CENTER">0</td>
<td align="CENTER">h</td>
<td align="CENTER">12</td>
</tr>
<tr><td align="RIGHT">12</td>
<td align="CENTER">12</td>
<td align="CENTER">11</td>
<td align="CENTER">l</td>
<td align="CENTER">0</td>
</tr>
</tbody></table>
<br>
<br><font size="+2"><b>from-space</b></font>
</td></tr>
</tbody></table>
<table width="173">
<tbody><tr><td>
<table border="1" cellpadding="3">
<tbody><tr><td align="RIGHT">51</td>
<td align="CENTER">51</td>
<td align="CENTER">52</td>
<td align="CENTER">e</td>
<td align="CENTER">54</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">52</td>
<td align="CENTER">52</td>
<td align="CENTER">55</td>
<td align="CENTER">b</td>
<td align="CENTER">56</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">53</td>
<td align="CENTER">53</td>
<td align="CENTER">0</td>
<td align="CENTER">j</td>
<td align="CENTER">57</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">54</td>
<td align="CENTER">54</td>
<td align="CENTER">0</td>
<td align="CENTER">d</td>
<td align="CENTER">58</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">55</td>
<td align="CENTER">55</td>
<td align="CENTER">0</td>
<td align="CENTER">c</td>
<td align="CENTER">0</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">56</td>
<td align="CENTER">56</td>
<td align="CENTER">57</td>
<td align="CENTER">k</td>
<td align="CENTER">0</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">57</td>
<td align="CENTER">57</td>
<td align="CENTER">0</td>
<td align="CENTER">f</td>
<td align="CENTER">0</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">58</td>
<td align="CENTER">58</td>
<td align="CENTER">0</td>
<td align="CENTER">a</td>
<td align="CENTER">0</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">59</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT"><!-- MATH
 $\leftarrow$
 -->
<img src="compiler_files/img1.png" alt="$ \leftarrow$" align="BOTTOM" border="0" height="10" width="17"> scan, next</td>
</tr>
<tr><td align="RIGHT">60</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">61</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
<tr><td align="RIGHT">62</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="LEFT">&nbsp;</td>
</tr>
</tbody></table>
<br>
<br><font size="+2"><b>to-space</b></font>
</td></tr>
</tbody></table>
<br>
<br>
Finally, the to-space becomes the new heap and the from-space is deallocated from memory.

</p><p>

</p><h2><a name="SECTION000143000000000000000">
13.3 Other Issues</a>
</h2>

<p>
For further reading, look at:

</p><ul>
<li>GC FAQ <a name="tex2html15" href="http://www.iecc.com/gclist/GC-faq.html">http://www.iecc.com/gclist/GC-faq.html</a>
</li>
<li>Allocation and GC Myths <a name="tex2html16" href="http://www.hpl.hp.com/personal/Hans_Boehm/gc/myths.ps">http://www.hpl.hp.com/personal/Hans_Boehm/gc/myths.ps</a>
</li>
</ul>

<p>
There is an excellent mark and sweep garbage collector for
C and C++ programs. It is called
gc (<a name="tex2html17" href="http://www.hpl.hp.com/personal/Hans_Boehm/gc/">http://www.hpl.hp.com/personal/Hans_Boehm/gc/</a>).

</p><p>
<br> </p><hr>
<address>
<i>Leonidas Fegaras <br>
2005-01-14</i>
</address>


</body></html>